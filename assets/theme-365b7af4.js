var le=Object.defineProperty;var de=(u,n,e)=>n in u?le(u,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[n]=e;var y=(u,n,e)=>(de(u,typeof n!="symbol"?n+"":n,e),e);import{a as g,T as R,f as ee,S as q,Q as U,b as V,F as L,C as te}from"./Translations-75f9b429.js";import{l as ce,S as he,D as pe,a as ue}from"./DashboardGui-435ed0fd.js";/* empty css                      */import"./List-085c0309.js";/* empty css                     *//* empty css                  */import{X as x,Y as b,Z as S,_ as v,$ as D,a0 as ge,a1 as ne,U as B,a2 as G,a3 as fe,m as me,d as ye,a4 as ve,L as ie,a5 as we,a6 as be,p as Te,a7 as _e,q as Q,M as Ae,D as K}from"./theme_overview-b3dcb03a.js";import{A as Re}from"./AllThemesGui-3c7ce79c.js";import{D as Se,A as Le}from"./AllKnownLayouts-2769bbb8.js";import{S as Z}from"./SubtleButton-11aede5a.js";import{C as Ce,l as X}from"./known_layers-7b28971b.js";import{C,T as P,A as se}from"./UserRelatedState-364a74ac.js";import{S as I}from"./MoreScreen-282eae66.js";import"./LanguagePicker-29d8ded1.js";import"./DropDown-13f177d0.js";import"./language_translations-a468e863.js";import"./Button-47b726a8.js";import"./UserInformation-b1e7af33.js";import"./Toggleable-ea6f5ac8.js";import"./defineProperty-1d73cb61.js";import"./BackToIndex-1f774bd2.js";class xe extends v{constructor(){super("Updates various attributes from the old data format to the new to provide backwards compatibility with the formats",["overpassTags","source.osmtags","tagRenderings[*].id","mapRendering"],"UpdateLegacyLayer")}convert(n,e){var o;const i=[];if(typeof n=="string"||n.builtin!==void 0)return{result:n,errors:[],warnings:[]};let t={...n};if(t.overpassTags&&(t.source=t.source??{osmTags:t.overpassTags},t.source.osmTags=t.overpassTags,delete t.overpassTags),t.tagRenderings!==void 0){let a=0;for(const s of t.tagRenderings)a++,!(typeof s=="string"||s.builtin!==void 0||s.rewrite!==void 0)&&s.id===void 0&&(s["#"]!==void 0?(s.id=s["#"],delete s["#"]):((o=s.freeform)==null?void 0:o.key)!==void 0?s.id=t.id+"-"+s.freeform.key:s.id="tr-"+a)}if(t.mapRendering===void 0){t.mapRendering=[];let a=["point"],s=t.wayHandling??0;if(s!==0&&(a=["point","centroid"]),t.icon??t.label!==void 0){const r={icon:t.icon,iconBadges:t.iconOverlays,label:t.label,iconSize:t.iconSize,location:a,rotation:t.rotation};t.mapRendering.push(r)}if(s!==1){const r={color:t.color,width:t.width,dashArray:t.dashArray};Object.keys(r).length>0&&t.mapRendering.push(r)}if(t.mapRendering.length===0)throw"Could not convert the legacy theme into a new theme: no renderings defined for layer "+t.id}delete t.color,delete t.width,delete t.dashArray,delete t.icon,delete t.iconOverlays,delete t.label,delete t.iconSize,delete t.rotation,delete t.wayHandling,delete t.hideUnderlayingFeaturesMinPercentage;for(const a of t.mapRendering??[]){a.iconOverlays!==void 0&&(a.iconBadges=a.iconOverlays);for(const s of a.iconBadges??[])s.badge!==!0&&i.push("Warning: non-overlay element for ",t.id),delete s.badge}return{result:t,errors:[],warnings:i}}}class ke extends v{constructor(){super("Small fixes in the theme config",["roamingRenderings"],"UpdateLegacyTheme")}convert(n,e){const i={...n};if(i.socialImage===""&&delete i.socialImage,i.roamingRenderings!==void 0)if(i.roamingRenderings.length==0)delete i.roamingRenderings;else return{result:null,errors:[e+": The theme contains roamingRenderings. These are not supported anymore"],warnings:[]};return i.layers=g.NoNull(i.layers),delete i.language,delete i.version,i.maintainer!==void 0&&(console.log("Maintainer: ",i.maintainer,"credits: ",i.credits),i.credits===void 0?(i.credits=i.maintainer,delete i.maintainer):(i.maintainer.toLowerCase().trim()==="mapcomplete"||i.maintainer.toLowerCase().trim()==="")&&delete i.maintainer),{errors:[],warnings:[],result:i}}}class $e extends x{constructor(){super("Fixes a legacy theme to the modern JSON format geared to humans. Syntactic sugars are kept (i.e. no tagRenderings are expandend, no dependencies are automatically gathered)",new ke,new b("layers",new S(new xe)))}}const ae=[{path:[],type:"object",description:`A TagRenderingConfigJson is a single piece of code which converts one ore more tags into a HTML-snippet.
For an _editable_ tagRendering, use 'QuestionableTagRenderingConfigJson' instead, which extends this one`},{path:["id"],type:"string",description:`The id of the tagrendering, should be an unique string.
Used to keep the translations in sync. Only used in the tagRenderings-array of a layerConfig, not requered otherwise.

Use 'questions' to trigger the question box of this group (if a group is defined)`},{path:["group"],type:"string",description:`If 'group' is defined on many tagRenderings, these are grouped together when shown. The questions are grouped together as well.
The first tagRendering of a group will always be a sticky element.`},{path:["labels"],type:"array",description:"A list of labels. These are strings that are used for various purposes, e.g. to filter them away"},{path:["description"],description:"A human-readable text explaining what this tagRendering does"},{path:["render"],typeHint:"rendered",description:`Renders this value. Note that "{key}"-parts are substituted by the corresponding values of the element.
If neither 'textFieldQuestion' nor 'mappings' are defined, this text is simply shown as default value.

Note that this is a HTML-interpreted value, so you can add links as e.g. '<a href='{website}'>{website}</a>' or include images such as \`This is of type A <br><img src='typeA-icon.svg' />\`
type: rendered`},{path:["condition"],type:[{$ref:"#/definitions/AndTagConfigJson",description:`Chain many tags, to match, a single of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{$ref:"#/definitions/OrTagConfigJson",description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{type:"string"}],description:`Only show this tagrendering (or ask the question) if the selected object also matches the tags specified as \`condition\`.

This is useful to ask a follow-up question.
For example, within toilets, asking _where_ the diaper changing table is is only useful _if_ there is one.
This can be done by adding \`"condition": "changing_table=yes"\`

A full example would be:
\`\`\`json
    {
      "question": "Where is the changing table located?",
      "render": "The changing table is located at {changing_table:location}",
      "condition": "changing_table=yes",
      "freeform": {
        "key": "changing_table:location",
        "inline": true
      },
      "mappings": [
        {
          "then": "The changing table is in the toilet for women.",
          "if": "changing_table:location=female_toilet"
        },
        {
          "then": "The changing table is in the toilet for men.",
          "if": "changing_table:location=male_toilet"
        },
        {
          "if": "changing_table:location=wheelchair_toilet",
          "then": "The changing table is in the toilet for wheelchair users.",
        },
        {
          "if": "changing_table:location=dedicated_room",
          "then": "The changing table is in a dedicated room. ",
        }
      ],
      "id": "toilet-changing_table:location"
    },
\`\`\``},{path:["condition"],type:"object",description:`Chain many tags, to match, a single of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{path:["condition","and"],type:[{$ref:"#/definitions/AndTagConfigJson"},{description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`,type:"object",properties:{or:{type:"array",items:{$ref:"#/definitions/TagConfigJson"}}},required:["or"]},{type:"string"}],description:`The main representation of Tags.
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for more documentation`},{path:["condition","and"],type:"object",description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{path:["condition"],type:"object",description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{path:["condition","or"],type:[{$ref:"#/definitions/AndTagConfigJson"},{description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`,type:"object",properties:{or:{type:"array",items:{$ref:"#/definitions/TagConfigJson"}}},required:["or"]},{type:"string"}],description:`The main representation of Tags.
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for more documentation`},{path:["condition","or"],type:"object",description:`Chain many tags, to match, a single of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{path:["condition","or"],type:"object",description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{path:["freeform"],type:"object",description:"Allow freeform text input from the user"},{path:["freeform","key"],type:"string",description:`If this key is present, then 'render' is used to display the value.
If this is undefined, the rendering is _always_ shown`},{path:["mappings"],type:"array",description:"Allows fixed-tag inputs, shown either as radiobuttons or as checkboxes"},{path:["mappings","if"],type:[{$ref:"#/definitions/AndTagConfigJson"},{description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`,type:"object",properties:{or:{type:"array",items:{$ref:"#/definitions/TagConfigJson"}}},required:["or"]},{type:"string"}],description:`The main representation of Tags.
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for more documentation`},{path:["mappings","if"],type:"object",description:`Chain many tags, to match, a single of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{path:["mappings","if"],type:"object",description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{path:["mappings","then"],typeHint:"rendered",description:"If the condition `if` is met, the text `then` will be rendered.\nIf not known yet, the user will be presented with `then` as an option\nType: rendered"},{path:["mappings","icon"],typeHint:"icon",type:[{type:"object",properties:{path:{description:`The path to the icon
Type: icon`,type:"string"},class:{description:`A hint to mapcomplete on how to render this icon within the mapping.
This is translated to 'mapping-icon-<classtype>', so defining your own in combination with a custom CSS is possible (but discouraged)`,type:"string"}},required:["class","path"]},{type:"string"}],description:`An icon supporting this mapping; typically shown pretty small
Type: icon`},{path:["mappings","icon","path"],typeHint:"icon",type:"string",description:`The path to the icon
Type: icon`},{path:["mappings","icon","class"],type:"string",description:`A hint to mapcomplete on how to render this icon within the mapping.
This is translated to 'mapping-icon-<classtype>', so defining your own in combination with a custom CSS is possible (but discouraged)`}],Ie=Object.freeze(Object.defineProperty({__proto__:null,default:ae},Symbol.toStringTag,{value:"Module"}));class re extends v{constructor(e=""){super("Adds a '_context' to every object that is probably a translation",["_context"],"AddContextToTranslation");y(this,"_prefix");this._prefix=e}convert(e,i){return e["#dont-translate"]==="*"?{result:e}:{result:g.WalkJson(e,(o,a)=>{if(o==null)return o;if(typeof o=="object"){let s=e;for(let r=0;r<a.length;r++){const l=a[r];s=s[l],l.match("[0-9]+")&&s.id!==void 0&&(a[r]=s.id)}return{...o,_context:this._prefix+i+"."+a.join(".")}}else return o},o=>o==null||R.isProbablyATranslation(o))}}}const De=[{id:"open_now",options:[{question:{en:"Opened now",nl:"Nu geopened",de:"Aktuell geöffnet",ca:"Obert ara",es:"Abierta ahora",fr:"Ouvert maintenant",hu:"Most nyitva van",da:"Åbent nu",zh_Hant:"目前開放",id:"Saat ini buka",it:"Aperto ora"},osmTags:"_isOpen=yes"}]},{id:"accepts_cash",options:[{osmTags:"payment:cash=yes",question:{en:"Accepts cash",de:"Akzeptiert Bargeld",nl:"Accepteert cash",es:"Acepta efectivo",fr:"Accepte les espèces"}}]},{id:"accepts_cards",options:[{osmTags:"payment:cards=yes",question:{en:"Accepts payment cards",de:"Akzeptiert Kartenzahlung",nl:"Accepteert betaalkaarten",es:"Acepta el pago por tarjeta",fr:"Accepte les cartes de paiement"}}]},{id:"has_image",options:[{question:{en:"With and without images",nl:"Met en zonder afbeelding",de:"Mit und ohne Bilder"}},{question:{en:"Has at least one image",de:"Hat mindestens ein Bild",nl:"Heeft minstens één afbeelding"},osmTags:{or:["image~*","image:0~*","image:1~*","image:2~*","image:3~*","mapillary~*"]}},{question:{en:"Probably does not have an image",de:"Hat wahrscheinlich kein Bild",nl:"Heeft waarschijnlijk geen afbeelding"},osmTags:{and:["image=","image:0=","image:1=","image:2=","image:3=","mapillary="]}}]},{id:"tactile_paving",options:[{question:{en:"With tactile paving",de:"Mit taktilem Pflaster",fr:"Avec revêtement podotactile",nl:"Met voelbare bestrating"},osmTags:"tactile_paving=yes"}]},{id:"tactile_paving_advanced",options:[{question:{en:"With or without tactile paving",de:"Mit oder ohne taktilem Pflaster",fr:"Avec ou sans revêtement podotactile",nl:"Met of zonder voelbare bestrating"}},{question:{en:"With tactile paving",de:"Mit taktilem Pflaster",fr:"Avec revêtement podotactile",nl:"Met voelbare bestrating"},osmTags:"tactile_paving=yes"},{question:{en:"Without tactile paving",de:"Ohne taktilem Pflaster",fr:"Sans revêtement podotactile",nl:"Zonder voelbare bestrating"},osmTags:"tactile_paving=no"},{osmTags:"tactile_paving=",question:{en:"No information about tactile paving",de:"Keine Informationen über taktiles Pflaster",fr:"Sans information sur le revêtement podotactile",nl:"Geen informatie over voelbare bestrating"}}]},{id:"has_organic",options:[{osmTags:{or:["organic=yes","organic=only"]},question:{en:"Has organic options",de:"Hat Bio-Produkte",nl:"Heeft biologische opties"}}]}],O=class extends v{static load_filters(){let n=new Map;for(const e of De)n.set(e.id,e);return n}constructor(){super("Expands filters: replaces a shorthand by the value found in 'filters.json'",["filter"],"ExpandFilter")}convert(n,e){if(n.filter===void 0||n.filter===null)return{result:n};if(n.filter.sameAs!==void 0)return{result:n};const i=[],t=[];for(const o of n.filter){if(typeof o!="string"){i.push(o);continue}const a=O.predefinedFilters.get(o);if(a===void 0){const s=g.sortedByLevenshteinDistance(o,Array.from(O.predefinedFilters.keys()),l=>l),r=e+".filter: while searching for predifined filter "+o+": this filter is not found. Perhaps you meant one of: "+s;t.push(r)}i.push(a)}return{result:{...n,filter:i},errors:t}}};let M=O;y(M,"predefinedFilters",O.load_filters());class E extends B{constructor(e,i,t){super("Converts a tagRenderingSpec into the full tagRendering, e.g. by substituting the tagRendering by the shared-question",[],"ExpandTagRendering");y(this,"_state");y(this,"_self");y(this,"_options");this._state=e,this._self=i,this._options=t}convert(e,i){const t=[],o=[];return{result:this.convertUntilStable(e,o,t,i),errors:t,warnings:o}}lookup(e){var h;const i=this._state;if(i.tagRenderings.has(e))return[i.tagRenderings.get(e)];if(e.indexOf(".")<0)return;const t=e.split(".");let o=i.sharedLayers.get(t[0]);if(t[0]===this._self.id&&(o=this._self),t.length!==2||o===void 0)return;const a=t[1],s=o.tagRenderings.filter(d=>d.id!==void 0);let r;if(a==="*")r=s;else if(a.startsWith("*")){const d=a.substring(1);r=s.filter(c=>{var f;return c.group===d||((f=c.labels)==null?void 0:f.indexOf(d))>=0})}else r=s.filter(d=>d.id===a);const l=new re("layers:");for(let d=0;d<r.length;d++){let c=g.Clone(r[d]);(h=this._options)!=null&&h.applyCondition&&(c.condition===void 0?c.condition=o.source.osmTags:c.condition={and:[c.condition,o.source.osmTags]}),c=l.convertStrict(c,o.id+".tagRenderings."+c.id),r[d]=c}if(r.length!==0)return r}convertOnce(e,i,t,o){const a=this._state;if(e==="questions")return[{id:"questions"}];if(typeof e=="string"){const s=this.lookup(e);return s===void 0?(o.indexOf("On(mapRendering")<0&&i.push(o+"A literal rendering was detected: "+e),[{render:e,id:e.replace(/[^a-zA-Z0-9]/g,"")}]):s}if(e.builtin!==void 0){let s=e.builtin;typeof s=="string"&&(s=[s]);for(const l of Object.keys(e))l==="builtin"||l==="override"||l==="id"||l.startsWith("#")||t.push("At "+o+": an object calling a builtin can only have keys `builtin` or `override`, but a key with name `"+l+"` was found. This won't be picked up! The full object is: "+JSON.stringify(e));const r=[];for(const l of s){const h=this.lookup(l);if(h===void 0){let d=Array.from(a.tagRenderings.keys());if(l.indexOf(".")>0){const[c]=l.split(".");let f=a.sharedLayers.get(c);if(c===this._self.id&&(f=this._self),f===void 0){const w=g.sortedByLevenshteinDistance(c,Array.from(a.sharedLayers.keys()),p=>p);a.sharedLayers.size===0?i.push(o+": BOOTSTRAPPING. Rerun generate layeroverview. While reusing tagrendering: "+l+": layer "+c+" not found. Maybe you meant on of "+w.slice(0,3).join(", ")):t.push(o+": While reusing tagrendering: "+l+": layer "+c+" not found. Maybe you meant on of "+w.slice(0,3).join(", "));continue}d=g.NoNull(f.tagRenderings.map(w=>w.id)).map(w=>c+"."+w)}d=g.sortedByLevenshteinDistance(l,d,c=>c),t.push(o+": The tagRendering with identifier "+l+` was not found.
	Did you mean one of `+d.join(", ")+`?
(Hint: did you add a new label and are you trying to use this label at the same time? Run 'reset:layeroverview' first`);continue}for(let d of h)d=g.Clone(d),g.Merge(e.override??{},d),r.push(d)}return r}return[e]}convertUntilStable(e,i,t,o){const a=this.convertOnce(e,i,t,o),s=[];for(const r of a)if(typeof r=="string"||r.builtin!==void 0){const l=this.convertUntilStable(r,i,t,o+"(RECURSIVE RESOLVE)");s.push(...l)}else s.push(r);return s}}class F extends B{constructor(){super("Applies a rewrite",[],"ExpandRewrite")}static RewriteParts(n,e,i){const t=R.isProbablyATranslation(e);function o(a,s){if(a===n)return s;if(typeof a=="string"){for(;a.indexOf(n)>=0;)a=a.replace(n,s);return a}if(Array.isArray(a))return a.map(r=>o(r,s));if(typeof a=="object"){a={...a};const r=t&&R.isProbablyATranslation(a);for(const l in a){let h=s;r&&s[l]!==void 0&&(h=s[l]),a[l]=o(a[l],h)}return a}return a}return o(i,e)}convert(n,e){if(n==null)return{result:[]};if(n.rewrite===void 0)return{result:[n]};const i=n,t=i.rewrite,o=[];for(let a=0;a<t.sourceString.length;a++){const s=t.sourceString[a];for(let r=a+1;r<t.sourceString.length;r++){const l=t.sourceString[r];if(l.indexOf(s)>=0)throw`${e} Error in rewrite: sourcestring[${a}] is a substring of sourcestring[${r}]: ${s} will be substituted away before ${l} is reached.`}}for(let a=0;a<i.rewrite.into.length;a++){const s=t.into[a];if(s.length!==i.rewrite.sourceString.length)throw`${e}.into.${a} Error in rewrite: there are ${i.rewrite.sourceString.length} keys to rewrite, but entry ${a} has only ${s.length} values`}for(let a=0;a<t.into.length;a++){let s=g.Clone(i.renderings);for(let r=0;r<t.sourceString.length;r++){const l=t.sourceString[r],h=t.into[a][r];s=F.RewriteParts(l,h,s)}o.push(s)}return{result:o}}}class J extends v{constructor(){super("Converts a 'special' translation into a regular translation which uses parameters",["special"],"RewriteSpecial")}static convertIfNeeded(n,e,i){const t=n.special;if(t===void 0)return n;const o=t.type;if(o===void 0){e.push("A 'special'-block should define 'type' to indicate which visualisation should be used");return}const a=G.specialVisualizations.find(p=>p.funcName===o);if(a===void 0){const p=g.sortedByLevenshteinDistance(o,G.specialVisualizations,m=>m.funcName);e.push(`Special visualisation '${o}' not found. Did you perhaps mean ${p[0].funcName}, ${p[1].funcName} or ${p[2].funcName}?
	For all known special visualisations, please see https://github.com/pietervdvn/MapComplete/blob/develop/Docs/SpecialRenderings.md`);return}e.push(...Array.from(Object.keys(n)).filter(p=>p!=="special"&&p!=="before"&&p!=="after").map(p=>`At ${i}: The only keys allowed next to a 'special'-block are 'before' and 'after'. Perhaps you meant to put '${p}' into the special block?`));const s=a.args.map(p=>p.name),r=new Set(s);e.push(...Object.keys(t).filter(p=>!r.has(p)).filter(p=>p!=="type"&&p!=="before"&&p!=="after").map(p=>{const m=g.sortedByLevenshteinDistance(p,s,T=>T);return`At ${i}: Unexpected argument in special block at ${i} with name '${p}'. Did you mean ${m[0]}?
	All known arguments are ${s.join(", ")}`}));for(const p of a.args){if(p.required!==!0)continue;t[p.name]===void 0&&e.push(`At ${i}: Obligated parameter '${p.name}' in special rendering of type ${a.funcName} not found.
${p.doc}`)}const l=new Set,h=s.map(p=>t[p]).filter(p=>p!==void 0).filter(p=>R.isProbablyATranslation(p));for(const p of h)for(const m of Object.keys(p))l.add(m);const d=R.T(n.before),c=R.T(n.after);for(const p of Object.keys((d==null?void 0:d.translations)??{}))l.add(p);for(const p of Object.keys((c==null?void 0:c.translations)??{}))l.add(p);if(l.size===0){const p=s.map(m=>t[m]??"").join(",");return{"*":`{${o}(${p})}`}}const f={},w=Array.from(l);w.sort();for(const p of w){const m=[];for(const $ of s){let A=t[$]??"";if(R.isProbablyATranslation(A)&&(A=new ee(A).textFor(p)),typeof A=="string"){const oe=A.replace(/,/g,"&COMMA").replace(/\{/g,"&LBRACE").replace(/}/g,"&RBRACE").replace(/\(/g,"&LPARENS").replace(/\)/g,"&RPARENS");m.push(oe)}else typeof A=="object"?m.push(JSON.stringify(A)):m.push(A)}const T=(d==null?void 0:d.textFor(p))??"",k=(c==null?void 0:c.textFor(p))??"";f[p]=`${T}{${o}(${m.map($=>$).join(",")})}${k}`}return f}convert(n,e){const i=[];n=g.Clone(n);const t=ae??Ie;for(const o of t)o.typeHint==="rendered"&&g.WalkPath(o.path,n,(a,s)=>J.convertIfNeeded(a,i,e+":"+s.join(".")));return{result:n,errors:i}}}class Y extends x{constructor(n){super("Fully prepares and expands a layer for the LayerConfig.",new b("tagRenderings",new S(new J)),new b("tagRenderings",new D(new F).andThenF(g.Flatten)),new b("tagRenderings",e=>new D(new E(n,e))),new b("mapRendering",new D(new F).andThenF(g.Flatten)),new b("mapRendering",e=>new S(new b("icon",new ge(new E(n,e,{applyCondition:!1}))))),new ne("titleIcons",["defaults"]),new b("titleIcons",e=>new D(new E(n,e))),new M)}}class Oe extends B{constructor(e){super("Converts the identifier of a builtin layer into the actual layer, or converts a 'builtin' syntax with override in the fully expanded form",[],"SubstituteLayer");y(this,"_state");this._state=e}convert(e,i){const t=[],o=[],a=this._state;function s(r){const h=Array.from(a.sharedLayers.keys()).map(c=>[c,g.levenshteinDistance(r,c)]);h.sort((c,f)=>c[1]-f[1]);const d=h.map(c=>c[0]);t.push(`${i}: The layer with name ${r} was not found as a builtin layer. Perhaps you meant ${d[0]}, ${d[1]} or ${d[2]}?
 For an overview of all available layers, refer to https://github.com/pietervdvn/MapComplete/blob/develop/Docs/BuiltinLayers.md`)}if(typeof e=="string"){const r=a.sharedLayers.get(e);return r===void 0?(s(e),{result:null,errors:t}):{result:[r],errors:t}}if(e.builtin!==void 0){let r=e.builtin;typeof r=="string"&&(r=[r]);const l=[];for(const h of r){const d=g.Clone(a.sharedLayers.get(h));if(d===void 0){s(h);continue}e.override.tagRenderings!==void 0&&(d.tagRenderings??[]).length>0&&t.push(`At ${i}: when overriding a layer, an override is not allowed to override into tagRenderings. Use "+tagRenderings" or "tagRenderings+" instead to prepend or append some questions.`);try{g.Merge(e.override,d),l.push(d)}catch(c){t.push(`At ${i}: could not apply an override due to: ${c}.
The override is: ${JSON.stringify(e.override)}`)}if(e.hideTagRenderingsWithLabels){const c=new Set(e.hideTagRenderingsWithLabels),f=new Set,w=[];for(const m of d.tagRenderings){const T=m.labels;if(T!==void 0){const k=T.findIndex($=>c.has($));if(k>=0){f.add(T[k]),o.push(i+": Dropping tagRendering "+m.id+" as it has a forbidden label: "+T[k]);continue}}if(c.has(m.id)){f.add(m.id),o.push(i+": Dropping tagRendering "+m.id+" as its id is a forbidden label");continue}if(c.has(m.group)){f.add(m.group),o.push(i+": Dropping tagRendering "+m.id+" as its group `"+m.group+"` is a forbidden label");continue}w.push(m)}const p=Array.from(c).filter(m=>!f.has(m));p.length>0&&t.push("This theme specifies that certain tagrenderings have to be removed based on forbidden layers. One or more of these layers did not match any tagRenderings and caused no deletions: "+p.join(", ")+`
   This means that this label can be removed or that the original tagRendering that should be deleted does not have this label anymore`),d.tagRenderings=w}}return{result:l,errors:t,information:o}}return{result:[e],errors:t}}}class Me extends v{constructor(e){super("Adds the default layers, namely: "+C.added_by_default.join(", "),["layers"],"AddDefaultLayers");y(this,"_state");this._state=e}convert(e,i){const t=[],o=[],a=this._state;e.layers=[...e.layers];const s=new Set(e.layers.map(r=>r.id));for(const r of C.added_by_default){const l=a.sharedLayers.get(r);if(l===void 0){t.push("Default layer "+r+" not found");continue}if(s.has(l.id)){o.push("Layout "+i+" already has a layer with name "+l.id+"; skipping inclusion of this builtin layer");continue}e.layers.push(l)}return{result:e,errors:t,warnings:o}}}class Ne extends v{constructor(){super("For every layer in the 'layers'-list, create a new layer which'll import notes. (Note that priviliged layers and layers which have a geojson-source set are ignored)",["layers"],"AddImportLayers")}convert(n,e){if(!(n.enableNoteImports??!0))return{warnings:["Not creating a note import layers for theme "+n.id+" as they are disabled"],result:n};const i=[];n={...n};const t=n.layers;n.layers=[...n.layers];const o=new Ce;for(let a=0;a<t.length;a++){const s=t[a];if(!(C.priviliged_layers.indexOf(s.id)>=0)&&s.source.geoJson===void 0&&!(s.title===void 0||s.name===void 0)&&!(s.presets===void 0||s.presets.length==0))try{const r=o.convert(s,e+".(noteimportlayer)["+a+"]");r.result!==void 0&&n.layers.push(r.result)}catch(r){i.push("Could not generate an import-layer for "+s.id+" due to "+r)}}return{errors:i,result:n}}}class H extends v{constructor(e){super("Adds a default 'minimap'-element to the tagrenderings if none of the elements define such a minimap",["tagRenderings"],"AddMiniMap");y(this,"_state");this._state=e}static hasMinimap(e){const i=g.NoNull([e.render,...(e.mappings??[]).map(t=>t.then)]);for(let t of i){typeof t=="string"&&(t={"*":t});for(const o in t){if(!t.hasOwnProperty(o))continue;const a=t[o];if(me.ExtractSpecialComponents(a).filter(l=>l.special!==void 0).some(l=>l.special.func.funcName==="minimap"))return!0}}return!1}convert(e,i){var a;const t=this._state;return(((a=e.tagRenderings)==null?void 0:a.some(s=>H.hasMinimap(s)))??!0)||(e={...e},e.tagRenderings=[...e.tagRenderings],e.tagRenderings.push(t.tagRenderings.get("questions")),e.tagRenderings.push(t.tagRenderings.get("minimap"))),{result:e}}}class Pe extends v{constructor(){super("Adds context to translations, including the prefix 'themes:json.id'; this is to make sure terms in an 'overrides' or inline layer are linkable too",["_context"],"AddContextToTranlationsInLayout")}convert(n,e){return new re("themes:").convert(n,n.id)}}class Fe extends v{constructor(){super("Applies 'overrideAll' onto every 'layer'. The 'overrideAll'-field is removed afterwards",["overrideAll","layers"],"ApplyOverrideAll")}convert(n,e){const i=n.overrideAll;if(i===void 0)return{result:n,warnings:[],errors:[]};n={...n},delete n.overrideAll;const t=[];for(let o of n.layers)o=g.Clone(o),g.Merge(i,o),t.push(o);return n.layers=t,{result:n,warnings:[],errors:[]}}}class W extends v{constructor(e){super(`If a layer has a dependency on another layer, these layers are added automatically on the theme. (For example: defibrillator depends on 'walls_and_buildings' to snap onto. This layer is added automatically)
            
            Note that these layers are added _at the start_ of the layer list, meaning that they will see _every_ feature.
            Furthermore, \`passAllFeatures\` will be set, so that they won't steal away features from further layers.
            Some layers (e.g. \`all_buildings_and_walls' or 'streets_with_a_name') are invisible, so by default, 'force_load' is set too.
            `,["layers"],"AddDependencyLayersToTheme");y(this,"_state");this._state=e}static CalculateDependencies(e,i,t){const o=[],a=new Set(e.map(r=>r.id));let s=[];do{const r=[];for(const l of e)try{const h=Se.getLayerDependencies(new ye(l,t+"(dependencies)"));r.push(...h)}catch(h){throw console.error(h),"Detecting layer dependencies for "+l.id+" failed due to "+h}for(const l of r)a.has(l.neededLayer)&&(e.find(h=>h.id===l.neededLayer).forceLoad=!0);s=r.filter(l=>!a.has(l.neededLayer));for(const l of s){if(a.has(l.neededLayer))continue;const h=g.Clone(i.get(l.neededLayer)),d="This layer is needed by "+l.neededBy+" because "+l.reason+" (at "+l.context+")";if(h===void 0)throw["Loading a dependency failed: layer "+l.neededLayer+" is not found, neither as layer of "+t+" nor as builtin layer.",d,"Loaded layers are: "+e.map(f=>f.id).join(",")].join(`
	`);h.forceLoad=!0,h.passAllFeatures=!0,h.description=d,o.unshift({config:h,reason:d}),a.add(h.id),s=s.filter(c=>c.neededLayer!==l.neededLayer)}}while(s.length>0);return o}convert(e,i){const t=this._state,o=t.sharedLayers,a=t.tagRenderings,s=[],r=e.layers;a.forEach((h,d)=>{h.id=d});const l=W.CalculateDependencies(r,o,e.id);for(const h of l);if(l.length>0)for(const h of l)s.push(i+": added "+h.config.id+" to the theme. "+h.reason);return r.unshift(...l.map(h=>h.config)),{result:{...e,layers:r},information:s}}}class Ee extends v{constructor(e){super("Adds every public layer to the personal theme",["layers"],"PreparePersonalTheme");y(this,"_state");this._state=e}convert(e,i){return e.id!=="personal"?{result:e}:(e.layers=Array.from(this._state.sharedLayers.keys()).filter(t=>C.priviliged_layers.indexOf(t)<0).filter(t=>this._state.publicLayers.has(t)),{result:e,information:["The personal theme has "+e.layers.length+" public layers"]})}}class qe extends v{constructor(){super("Generates a warning if a theme uses an unsubstituted layer",["layers"],"WarnForUnsubstitutedLayersInTheme")}convert(n,e){if(n.hideFromOverview===!0)return{result:n};const i=[];for(const t of n.layers){if(typeof t=="string"||t.builtin!==void 0||t.source.geojson!==void 0)continue;const o="The theme "+n.id+" has an inline layer: "+t.id+". This is discouraged.";i.push(o)}return{result:n,warnings:i}}}class Ue extends x{constructor(n,e){super("Fully prepares and expands a theme",new Pe,new Ee(n),new qe,new b("layers",new D(new Oe(n))),new ne("socialImage","assets/SocialImage.png",!0),new b("layers",new S(new Y(n))),new Fe,new b("layers",new S(new Y(n))),e!=null&&e.skipDefaultLayers?new fe("AddDefaultLayers is disabled due to the set flag"):new Me(n),new W(n),new Ne,new b("layers",new S(new H(n))))}}class j extends v{constructor(...e){super("Checks that the given object is fully translated in the specified languages",[],"ValidateLanguageCompleteness");y(this,"_languages");this._languages=e??["en"]}convert(e,i){const t=[],o=ee.ExtractAllTranslationsFrom(e);for(const a of this._languages)o.filter(s=>s.tr.translations[a]===void 0&&s.tr.translations["*"]===void 0).forEach(s=>{t.push(i+"A theme should be translation-complete for "+a+", but it lacks a translation for "+s.context+`.
	The known translation is `+s.tr.textFor("en"))});return{result:e,errors:t}}}class Be extends v{constructor(e,i=void 0){super("Checks if an image exists",[],"DoesImageExist");y(this,"_knownImagePaths");y(this,"doesPathExist");this._knownImagePaths=e,this.doesPathExist=i}convert(e,i){const t=[],o=[],a=[];return e.indexOf("{")>=0?(a.push("Ignoring image with { in the path: "+e),{result:e}):e==="assets/SocialImage.png"?{result:e}:e.match(/[a-z]*/)&&q.All[e+".svg"]!==void 0?{result:e}:(this._knownImagePaths.has(e)||(this.doesPathExist===void 0?t.push(`Image with path ${e} not found or not attributed; it is used in ${i}`):this.doesPathExist(e)?t.push(`Image with path ${e} is not attributed (but it exists); execute 'npm run query:licenses' to add the license information and/or run 'npm run generate:licenses' to compile all the license info`):t.push(`Image with path ${e} does not exist; it is used in ${i}.
     Check for typo's and missing directories in the path.`)),{result:e,errors:t,warnings:o,information:a})}}class Je extends v{constructor(e,i,t,o){super("Doesn't change anything, but emits warnings and errors",[],"ValidateTheme");y(this,"_path");y(this,"_isBuiltin");y(this,"_sharedTagRenderings");y(this,"_validateImage");this._validateImage=e,this._path=i,this._isBuiltin=t,this._sharedTagRenderings=o}convert(e,i){const t=[],o=[],a=[],s=new ie(e,this._isBuiltin);if(this._isBuiltin&&(e.units!==void 0&&t.push("The theme "+e.id+" has units defined - these should be defined on the layer instead. (Hint: use overrideAll: { '+units': ... }) "),e.roamingRenderings!==void 0&&t.push("Theme "+e.id+" contains an old 'roamingRenderings'. Use an 'overrideAll' instead")),this._isBuiltin){const r=new we(this._isBuiltin,this._sharedTagRenderings).convertStrict(e,"validation"),l=r.filter(h=>h.indexOf("http")==0);for(const h of l)t.push("Found a remote image: "+h+" in theme "+e.id+", please download it.");for(const h of r)this._validateImage.convertJoin(h,i===void 0?"":` in a layer defined in the theme ${i}`,t,o,a)}try{if(this._isBuiltin){s.id!==s.id.toLowerCase()&&t.push("Theme ids should be in lowercase, but it is "+s.id);const l=this._path.substring(this._path.lastIndexOf("/")+1,this._path.length-5);s.id!==l&&t.push("Theme ids should be the same as the name.json, but we got id: "+s.id+" and filename "+l+" ("+this._path+")"),this._validateImage.convertJoin(s.icon,i+".icon",t,o,a)}const r=g.Dupiclates(e.layers.map(l=>l.id));if(r.length>0&&t.push(`The theme ${e.id} defines multiple layers with id ${r.join(", ")}`),e.mustHaveLanguage!==void 0){const l=new j(...e.mustHaveLanguage).convert(s,s.id);t.push(...l.errors)}if(!e.hideFromOverview&&s.id!=="personal"&&this._isBuiltin){const l=s.title.SupportedLanguages()[0];l!=="en"&&o.push(`TargetLanguage is not 'en' for public theme ${s.id}, it is ${l}. Move 'en' up in the title of the theme and set it as the first key`);const h=new j("en").convert(s,s.id);t.push(...h.errors)}}catch(r){t.push(r)}return{result:e,errors:t,warnings:o,information:a}}}class He extends x{constructor(n,e,i,t){super("Validates a theme and the contained layers",new Je(n,e,i,t),new b("layers",new S(new Ke(void 0,i,n))))}}class We extends v{constructor(){super("Checks that an 'overrideAll' does not override a single override",[],"OverrideShadowingCheck")}convert(n,e){const i=n.overrideAll;if(i===void 0)return{result:n};const t=[],o=n.layers.filter(a=>a.override!==void 0);for(const a of o)for(const s in i)if(!(s.endsWith("+")||s.startsWith("+"))&&(a.override[s]!==void 0||a.override["="+s]!==void 0)){const r="The override of layer "+JSON.stringify(a.builtin)+" has a shadowed property: "+s+" is overriden by overrideAll of the theme";t.push(r)}return{result:n,errors:t}}}class ze extends v{constructor(){super("Miscelleanous checks on the theme",[],"MiscThemesChecks")}convert(n,e){const i=[],t=[];return n.id!=="personal"&&(n.layers===void 0||n.layers.length===0)&&t.push("The theme "+n.id+" has no 'layers' defined ("+e+")"),n.socialImage===""&&i.push("Social image for theme "+n.id+" is the emtpy string"),{result:n,warnings:i,errors:t}}}class Ve extends x{constructor(){super("Various consistency checks on the raw JSON",new ze,new We)}}class z extends v{constructor(e){super("Checks that the mappings don't shadow each other",[],"DetectShadowedMappings");y(this,"_calculatedTagNames");this._calculatedTagNames=z.extractCalculatedTagNames(e)}static extractCalculatedTagNames(e){var i;return((i=e==null?void 0:e.calculatedTags)==null?void 0:i.map(t=>t.indexOf(":=")>=0?t.split(":=")[0]:t.split("=")[0]))??[]}convert(e,i){const t=[],o=[];if(e.mappings===void 0||e.mappings.length===0)return{result:e};const a={};for(const r of this._calculatedTagNames)a[r]="some_calculated_tag_value_for_"+r;const s=e.mappings.map((r,l)=>{const h=`${i}.mappings[${l}]`,d=P.Tag(r.if,h);if(r.hideInAnswer!==void 0&&r.hideInAnswer!==!1&&r.hideInAnswer!==!0){let c=P.Tag(r.hideInAnswer);return new se([c,d])}return d});for(let r=0;r<e.mappings.length;r++){if(!s[r].isUsableAsAnswer())continue;const l=s[r].asChange(a),h={};l.forEach(({k:d,v:c})=>{h[d]=c});for(let d=0;d<r;d++){const c=s[d].matchesProperties(h);c&&e.mappings[d].hideInAnswer===!0&&e.mappings[r].hideInAnswer!==!0?o.push(`At ${i}: Mapping ${r} is shadowed by mapping ${d}. However, mapping ${d} has 'hideInAnswer' set, which will result in a different rendering in question-mode.`):c&&t.push(`At ${i}: Mapping ${r} is shadowed by mapping ${d} and will thus never be shown:
    The mapping ${s[r].asHumanString(!1,!1,{})} is fully matched by a previous mapping (namely ${d}), which matches:
    ${s[d].asHumanString(!1,!1,{})}.

    To fix this problem, you can try to:
    - Move the shadowed mapping up
    - Do you want to use a different text in 'question mode'? Add 'hideInAnswer=true' to the first mapping
    - Use "addExtraTags": ["key=value", ...] in order to avoid a different rendering
         (e.g. [{"if": "fee=no",                     "then": "Free to use", "hideInAnswer":true},
                {"if": {"and":["fee=no","charge="]}, "then": "Free to use"}]
          can be replaced by
               [{"if":"fee=no", "then": "Free to use", "addExtraTags": ["charge="]}]
`)}}return{errors:t,warnings:o,result:e}}}class Ge extends v{constructor(e){super("Checks that 'then'clauses in mappings don't have images, but use 'icon' instead",[],"DetectMappingsWithImages");y(this,"_doesImageExist");this._doesImageExist=e}convert(e,i){var r,l;const t=[],o=[],a=[];if(e.mappings===void 0||e.mappings.length===0)return{result:e};const s="ignore-image-in-then";for(let h=0;h<e.mappings.length;h++){const d=e.mappings[h],c=((r=d["#"])==null?void 0:r.indexOf(s))>=0,f=g.Dedup(((l=R.T(d.then))==null?void 0:l.ExtractImages())??[]),w=`${i}.mappings[${h}]`;if(f.length>0)if(!c)t.push(`${w}: A mapping has an image in the 'then'-clause. Remove the image there and use \`"icon": <your-image>\` instead. The images found are ${f.join(", ")}. (This check can be turned of by adding "#": "${s}" in the mapping, but this is discouraged`);else{a.push(`${w}: Ignored image ${f.join(", ")} in 'then'-clause of a mapping as this check has been disabled`);for(const p of f)this._doesImageExist.convertJoin(p,w,t,o,a)}else c&&o.push(`${w}: unused '${s}' - please remove this`)}return{errors:t,warnings:o,information:a,result:e}}}class Qe extends x{constructor(n,e){super("Various validation on tagRenderingConfigs",new z(n),new Ge(e))}}class Ke extends v{constructor(e,i,t){super("Doesn't change anything, but emits warnings and errors",[],"ValidateLayer");y(this,"_path");y(this,"_isBuiltin");y(this,"_doesImageExist");this._path=e,this._isBuiltin=i,this._doesImageExist=t}convert(e,i){var s,r,l,h;const t=[],o=[],a=[];if(i="While validating a layer: "+i,typeof e=="string")return t.push(i+": This layer hasn't been expanded: "+e),{result:null,errors:t};if(e.tagRenderings!==void 0&&e.tagRenderings.length>0&&(e.title===void 0&&t.push(i+": this layer does not have a title defined but it does have tagRenderings. Not having a title will disable the popups, resulting in an unclickable element. Please add a title. If not having a popup is intended and the tagrenderings need to be kept (e.g. in a library layer), set `title: null` to disable this error."),e.title===null&&a.push(i+": title is `null`. This results in an element that cannot be clicked - even though tagRenderings is set.")),e.builtin!==void 0)return t.push(i+": This layer hasn't been expanded: "+e),{result:null,errors:t};e.minzoom>C.userJourney.minZoomLevelToAddNewPoints&&(((s=e.presets)==null?void 0:s.length)>0?t:o).push(`At ${i}: minzoom is ${e.minzoom}, this should be at most ${C.userJourney.minZoomLevelToAddNewPoints} as a preset is set. Why? Selecting the pin for a new item will zoom in to level before adding the point. Having a greater minzoom will hide the points, resulting in possible duplicates`);{const d=g.Dedup(g.Dupiclates(g.NoNull((e.tagRenderings??[]).map(c=>c.id)))).filter(c=>c!=="questions");d.length>0&&t.push("At "+i+": some tagrenderings have a duplicate id: "+d.join(", "))}e.deletion!==void 0&&e.deletion instanceof ve&&e.deletion.softDeletionTags===void 0&&o.push("No soft-deletion tags in deletion block for layer "+e.id);try{if(this._isBuiltin){e.overpassTags!==void 0&&t.push("Layer "+e.id+`still uses the old 'overpassTags'-format. Please use "source": {"osmTags": <tags>}' instead of "overpassTags": <tags> (note: this isn't your fault, the custom theme generator still spits out the old format)`);const d=["icon","wayHandling","roamingRenderings","roamingRendering","label","width","color","colour","iconOverlays"];for(const c of d)e[c]!==void 0&&t.push(i+": layer "+e.id+" still has a forbidden key "+c);e.hideUnderlayingFeaturesMinPercentage!==void 0&&t.push(i+": layer "+e.id+" contains an old 'hideUnderlayingFeaturesMinPercentage'"),e.isShown!==void 0&&(e.isShown.render!==void 0||e.isShown.mappings!==void 0)&&o.push(i+" has a tagRendering as `isShown`")}if(this._isBuiltin){const d=`assets/layers/${e.id}/${e.id}.json`;this._path!=null&&this._path.indexOf(d)<0&&t.push("Layer is in an incorrect place. The path is "+this._path+", but expected "+d)}if(this._isBuiltin){if((r=e.tagRenderings)!=null&&r.some(c=>c.id==="")){const c=[];for(let f=0;f<e.tagRenderings.length;f++)e.tagRenderings[f].id===""&&c.push(f);t.push(`Some tagrendering-ids are empty or have an emtpy string; this is not allowed (at ${i}.tagRenderings.[${c.join(",")}])`)}const d=g.Dupiclates((l=e.tagRenderings??[])==null?void 0:l.map(c=>c.id).filter(c=>c!=="questions"));d.length>0&&!g.runningFromConsole&&t.push(`Some tagRenderings have a duplicate id: ${d} (at ${i}.tagRenderings)`),e.description===void 0&&(C.priviliged_layers.indexOf(e.id)>=0?t.push(i+": A priviliged layer must have a description"):o.push(i+": A builtin layer should have a description"))}if(e.tagRenderings!==void 0){const d=new b("tagRenderings",new S(new Qe(e,this._doesImageExist))).convert(e,i);o.push(...d.warnings??[]),t.push(...d.errors??[]),a.push(...d.information??[])}{const d=(h=e.mapRendering)==null?void 0:h.filter(c=>c.icon!==void 0&&c.icon.condition!==void 0);(d==null?void 0:d.length)>0&&t.push("At "+i+`:
    One or more icons in the mapRenderings have a condition set. Don't do this, as this will result in an invisible but clickable element. Use extra filters in the source instead. The offending mapRenderings are:
`+JSON.stringify(d,null,"  "))}if(e.presets!==void 0){const d=P.Tag(e.source.osmTags);for(let c=0;c<e.presets.length;c++){const f=e.presets[c],w=new se(f.tags.map(T=>P.Tag(T))).asChange({id:"node/-1"}),p={};for(const T of w)p[T.k]=T.v;d.matchesProperties(p)||t.push(i+".presets["+c+`]: This preset does not match the required tags of this layer. This implies that a newly added point will not show up.
    A newly created point will have properties: `+JSON.stringify(p)+`
    The required tags are: `+d.asHumanString(!1,!1,{}))}}}catch(d){t.push(d)}return{result:e,errors:t,warnings:o,information:a}}}const _=class{static async GetLayout(){const n=U.GetQueryParameter("userlayout","false",`If not 'false', a custom (non-official) theme is loaded. This custom layout can be done in multiple ways: 

- The hash of the URL contains a base64-encoded .json-file containing the theme definition
- The hash of the URL contains a lz-compressed .json-file, as generated by the custom theme generator
- The parameter itself is an URL, in which case that URL will be downloaded. It should point to a .json of a theme`),e=decodeURIComponent(n.data);if(e.startsWith("http"))return await _.LoadRemoteTheme(e);if(e!=="false")return _.LoadLayoutFromHash(n);let i;const t=window.location.pathname.split("/").slice(-1)[0];return t!=="theme.html"&&t!==""&&(i=t,t.endsWith(".html")&&(i=t.substr(0,t.length-5)),console.log("Using layout",i)),i=U.GetQueryParameter("layout",i,"The layout to load into MapComplete").data,Le.allKnownLayouts.get(i==null?void 0:i.toLowerCase())}static LoadLayoutFromHash(n){var t,o;let e=location.hash.substr(1),i;try{const a=V.Get("user-layout-"+((t=n.data)==null?void 0:t.replace(" ","_")));((o=a.data)==null?void 0:o.length)<10&&a.setData(void 0);const s=V.Get("last-loaded-user-layout");e.length<10?e=a.data??s.data:(console.log("Saving hash to local storage"),s.setData(e),a.setData(e));try{i=JSON.parse(atob(e))}catch{try{i=JSON.parse(g.UnMinify(ce.decompressFromBase64(e)))}catch(h){return console.error(h),_.ShowErrorOnCustomTheme("Could not decode the hash",new L("Not a valid (LZ-compressed) JSON")),null}}const r=_.prepCustomTheme(i);return n.setData(r.id),r}catch(a){return console.error(a),(e===void 0||e.length<10)&&_.ShowErrorOnCustomTheme("Could not load a theme from the hash",new L("Hash does not contain data"),i),this.ShowErrorOnCustomTheme("Could not parse the hash",new L(a),i),null}}static ShowErrorOnCustomTheme(n="Error: could not parse the custom layout:",e,i){new te([n,e.SetClass("alert"),new Z(q.back_svg(),"Go back to the theme overview",{url:window.location.protocol+"//"+window.location.host+"/index.html",newTab:!1}),i!==void 0?new Z(q.download_svg(),"Download the JSON file").onClick(()=>{g.offerContentsAsDownloadableFile(JSON.stringify(i,null,"  "),"theme_definition.json")}):void 0]).SetClass("flex flex-col clickable").AttachTo("centermessage")}static prepCustomTheme(n,e,i){if(n.layers===void 0&&n.tagRenderings!==void 0){const s=n.mapRendering.map(l=>l.icon).find(l=>l!==void 0),r=new Te(s).render.txt;n={id:n.id,description:n.description,descriptionTail:{en:"<div class='alert'>Layer only mode.</div> The loaded custom theme actually isn't a custom theme, but only contains a layer."},icon:r,title:n.name,layers:[n]}}const t=new Map;for(const s in X){const r=X[s];t.set(r.id,r)}const o={tagRenderings:Q.SharedTagRenderingJson,sharedLayers:t,publicLayers:new Set};n=new $e().convertStrict(n,"While loading a dynamic theme");const a=n;n=new _e(_._knownImages).convertStrict(n,"While fixing the images"),n.enableNoteImports=n.enableNoteImports??!1,n=new Ue(o).convertStrict(n,"While preparing a dynamic theme"),console.log("The layoutconfig is ",n),n.id=i??n.id;{let{errors:s}=new Ve().convert(n,"validation");if(s.length>0)throw"Detected errors: "+s.join(`
`)}{let{errors:s}=new He(new Be(new Set,r=>!0),"",!1,Q.SharedTagRendering).convert(n,"validation");if(s.length>0)throw"Detected errors: "+s.join(`
`)}return new ie(n,!1,{definitionRaw:JSON.stringify(a,null,"  "),definedAtUrl:e})}static async LoadRemoteTheme(n){console.log("Downloading map theme from ",n),new L(`Downloading the theme from the <a href="${n}">link</a>...`).AttachTo("centermessage");try{let e=await g.downloadJson(n);try{let i=e.id;const t=new URL(n);return t.hostname==="localhost"||t.hostname==="127.0.0.1"||(i=n),console.log("Loaded remote link:",n),_.prepCustomTheme(e,n,i)}catch(i){return console.error(i),_.ShowErrorOnCustomTheme(`<a href="${n}">${n}</a> is invalid:`,new L(i),e),null}}catch(e){return console.error(e),_.ShowErrorOnCustomTheme(`<a href="${n}">${n}</a> is invalid - probably not found or invalid JSON:`,new L(e)),null}}};let N=_;y(N,"_knownImages",new Set(Array.from(be).map(n=>n.path)));Ae.initialize();he.Implement();g.DisableLongPresses();class Ze{static Init(n){if(n===null)return;if(n===void 0){new Re().setup();return}const e=new K;I.state=new I(n),K.state=e,window.mapcomplete_state=I.state,U.GetQueryParameter("mode","map","The mode the application starts in, e.g. 'map', 'dashboard' or 'statistics'").data==="dashboard"?new pe(I.state,e).setup():new ue(I.state,e).setup()}}document.getElementById("decoration-desktop").remove();new te(["Initializing... <br/>",new L("<a>If this message persist, something went wrong - click here to try again</a>").SetClass("link-underline small").onClick(()=>{localStorage.clear(),window.location.reload(!0)})]).AttachTo("centermessage");N.GetLayout().then(u=>{console.log("Got ",u),Ze.Init(u)}).catch(u=>{console.error("Error while initializing: ",u,u.stack)});
