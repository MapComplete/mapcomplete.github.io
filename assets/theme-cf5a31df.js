var de=Object.defineProperty;var le=(g,i,e)=>i in g?de(g,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):g[i]=e;var y=(g,i,e)=>(le(g,typeof i!="symbol"?i+"":i,e),e);import{J as f,T as R,R as ee,S as B,Y as ce,Q as q,L as G,F as x,C as te}from"./SvelteUIElement-40cac351.js";import{l as he,S as pe,D as ue,a as ge}from"./DashboardGui-4a1f0da0.js";import"./ToSvelte-6ff26f66.js";/* empty css                        *//* empty css                     *//* empty css                  */import{X as k,Y as b,Z as S,_ as w,$ as D,a0 as ne,U as H,a1 as Q,a2 as fe,n as ie,a3 as me,d as ye,a4 as ve,a5 as we,L as se,a6 as be,q as Te,a7 as _e,r as Ae,M as Re,D as K}from"./theme_overview-f1f8a5ec.js";import{A as Le}from"./AllThemesGui-8d71aa66.js";import{A as Se}from"./AllKnownLayouts-0d876083.js";import{S as Z}from"./SubtleButton-8f35a13d.js";import{C as xe,k as Y}from"./known_layers-4f2c247c.js";import{C}from"./BBox-ca322623.js";import{E as Ce,S as I}from"./MoreScreen-420f6cb1.js";import{a as F,c as ae}from"./ChartJs-dcded48d.js";import"./LanguagePicker-bef8564c.js";import"./List-031c78c4.js";import"./language_native-373a312a.js";import"./language_translations-1c14410d.js";import"./UserInformation-766e2709.js";import"./defineProperty-bf1f4e26.js";import"./_commonjsHelpers-edff4021.js";import"./ContactLink-6e837969.js";import"./BackToIndex-193d58bd.js";class ke extends w{constructor(){super("Updates various attributes from the old data format to the new to provide backwards compatibility with the formats",["overpassTags","source.osmtags","tagRenderings[*].id","mapRendering"],"UpdateLegacyLayer")}convert(i,e){var o;const n=[];if(typeof i=="string"||i.builtin!==void 0)return{result:i,errors:[],warnings:[]};let t={...i};if(t.overpassTags&&(t.source=t.source??{osmTags:t.overpassTags},t.source.osmTags=t.overpassTags,delete t.overpassTags),t.tagRenderings!==void 0){let s=0;for(const a of t.tagRenderings)s++,!(typeof a=="string"||a.builtin!==void 0||a.rewrite!==void 0)&&a.id===void 0&&(a["#"]!==void 0?(a.id=a["#"],delete a["#"]):((o=a.freeform)==null?void 0:o.key)!==void 0?a.id=t.id+"-"+a.freeform.key:a.id="tr-"+s)}if(t.mapRendering===void 0){t.mapRendering=[];let s=["point"],a=t.wayHandling??0;if(a!==0&&(s=["point","centroid"]),t.icon??t.label!==void 0){const r={icon:t.icon,iconBadges:t.iconOverlays,label:t.label,iconSize:t.iconSize,location:s,rotation:t.rotation};t.mapRendering.push(r)}if(a!==1){const r={color:t.color,width:t.width,dashArray:t.dashArray};Object.keys(r).length>0&&t.mapRendering.push(r)}if(t.mapRendering.length===0)throw"Could not convert the legacy theme into a new theme: no renderings defined for layer "+t.id}delete t.color,delete t.width,delete t.dashArray,delete t.icon,delete t.iconOverlays,delete t.label,delete t.iconSize,delete t.rotation,delete t.wayHandling,delete t.hideUnderlayingFeaturesMinPercentage;for(const s of t.mapRendering??[]){s.iconOverlays!==void 0&&(s.iconBadges=s.iconOverlays);for(const a of s.iconBadges??[])a.badge!==!0&&n.push("Warning: non-overlay element for ",t.id),delete a.badge}return{result:t,errors:[],warnings:n}}}class $e extends w{constructor(){super("Small fixes in the theme config",["roamingRenderings"],"UpdateLegacyTheme")}convert(i,e){const n={...i};if(n.socialImage===""&&delete n.socialImage,n.roamingRenderings!==void 0)if(n.roamingRenderings.length==0)delete n.roamingRenderings;else return{result:null,errors:[e+": The theme contains roamingRenderings. These are not supported anymore"],warnings:[]};return n.layers=f.NoNull(n.layers),delete n.language,delete n.version,n.maintainer!==void 0&&(console.log("Maintainer: ",n.maintainer,"credits: ",n.credits),n.credits===void 0?(n.credits=n.maintainer,delete n.maintainer):(n.maintainer.toLowerCase().trim()==="mapcomplete"||n.maintainer.toLowerCase().trim()==="")&&delete n.maintainer),{errors:[],warnings:[],result:n}}}class Ie extends k{constructor(){super("Fixes a legacy theme to the modern JSON format geared to humans. Syntactic sugars are kept (i.e. no tagRenderings are expandend, no dependencies are automatically gathered)",new $e,new b("layers",new S(new ke)))}}const De=[{path:[],type:"object",description:`A TagRenderingConfigJson is a single piece of code which converts one ore more tags into a HTML-snippet.
For an _editable_ tagRendering, use 'QuestionableTagRenderingConfigJson' instead, which extends this one`},{path:["id"],type:"string",description:`The id of the tagrendering, should be an unique string.
Used to keep the translations in sync. Only used in the tagRenderings-array of a layerConfig, not requered otherwise.

Use 'questions' to trigger the question box of this group (if a group is defined)`},{path:["group"],type:"string",description:`If 'group' is defined on many tagRenderings, these are grouped together when shown. The questions are grouped together as well.
The first tagRendering of a group will always be a sticky element.`},{path:["labels"],type:"array",description:"A list of labels. These are strings that are used for various purposes, e.g. to filter them away"},{path:["description"],description:"A human-readable text explaining what this tagRendering does"},{path:["render"],typeHint:"rendered",description:`Renders this value. Note that "{key}"-parts are substituted by the corresponding values of the element.
If neither 'textFieldQuestion' nor 'mappings' are defined, this text is simply shown as default value.

Note that this is a HTML-interpreted value, so you can add links as e.g. '<a href='{website}'>{website}</a>' or include images such as \`This is of type A <br><img src='typeA-icon.svg' />\`
type: rendered`},{path:["condition"],type:[{$ref:"#/definitions/AndTagConfigJson",description:`Chain many tags, to match, a single of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{$ref:"#/definitions/OrTagConfigJson",description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{type:"string"}],description:`Only show this tagrendering (or ask the question) if the selected object also matches the tags specified as \`condition\`.

This is useful to ask a follow-up question.
For example, within toilets, asking _where_ the diaper changing table is is only useful _if_ there is one.
This can be done by adding \`"condition": "changing_table=yes"\`

A full example would be:
\`\`\`json
    {
      "question": "Where is the changing table located?",
      "render": "The changing table is located at {changing_table:location}",
      "condition": "changing_table=yes",
      "freeform": {
        "key": "changing_table:location",
        "inline": true
      },
      "mappings": [
        {
          "then": "The changing table is in the toilet for women.",
          "if": "changing_table:location=female_toilet"
        },
        {
          "then": "The changing table is in the toilet for men.",
          "if": "changing_table:location=male_toilet"
        },
        {
          "if": "changing_table:location=wheelchair_toilet",
          "then": "The changing table is in the toilet for wheelchair users.",
        },
        {
          "if": "changing_table:location=dedicated_room",
          "then": "The changing table is in a dedicated room. ",
        }
      ],
      "id": "toilet-changing_table:location"
    },
\`\`\``},{path:["condition"],type:"object",description:`Chain many tags, to match, a single of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{path:["condition","and"],type:[{$ref:"#/definitions/AndTagConfigJson"},{description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`,type:"object",properties:{or:{type:"array",items:{$ref:"#/definitions/TagConfigJson"}}},required:["or"]},{type:"string"}],description:`The main representation of Tags.
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for more documentation`},{path:["condition","and"],type:"object",description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{path:["condition"],type:"object",description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{path:["condition","or"],type:[{$ref:"#/definitions/AndTagConfigJson"},{description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`,type:"object",properties:{or:{type:"array",items:{$ref:"#/definitions/TagConfigJson"}}},required:["or"]},{type:"string"}],description:`The main representation of Tags.
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for more documentation`},{path:["condition","or"],type:"object",description:`Chain many tags, to match, a single of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{path:["condition","or"],type:"object",description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{path:["freeform"],type:"object",description:"Allow freeform text input from the user"},{path:["freeform","key"],type:"string",description:`If this key is present, then 'render' is used to display the value.
If this is undefined, the rendering is _always_ shown`},{path:["mappings"],type:"array",description:"Allows fixed-tag inputs, shown either as radiobuttons or as checkboxes"},{path:["mappings","if"],type:[{$ref:"#/definitions/AndTagConfigJson"},{description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`,type:"object",properties:{or:{type:"array",items:{$ref:"#/definitions/TagConfigJson"}}},required:["or"]},{type:"string"}],description:`The main representation of Tags.
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for more documentation`},{path:["mappings","if"],type:"object",description:`Chain many tags, to match, a single of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{path:["mappings","if"],type:"object",description:`Chain many tags, to match, all of these should be true
See https://github.com/pietervdvn/MapComplete/blob/develop/Docs/Tags_format.md for documentation`},{path:["mappings","then"],typeHint:"rendered",description:"If the condition `if` is met, the text `then` will be rendered.\nIf not known yet, the user will be presented with `then` as an option\nType: rendered"},{path:["mappings","icon"],typeHint:"icon",type:[{type:"object",properties:{path:{description:`The path to the icon
Type: icon`,type:"string"},class:{description:`A hint to mapcomplete on how to render this icon within the mapping.
This is translated to 'mapping-icon-<classtype>', so defining your own in combination with a custom CSS is possible (but discouraged)`,type:"string"}},required:["path"]},{type:"string"}],description:`An icon supporting this mapping; typically shown pretty small
Type: icon`},{path:["mappings","icon","path"],typeHint:"icon",type:"string",description:`The path to the icon
Type: icon`},{path:["mappings","icon","class"],type:"string",description:`A hint to mapcomplete on how to render this icon within the mapping.
This is translated to 'mapping-icon-<classtype>', so defining your own in combination with a custom CSS is possible (but discouraged)`}];class re extends w{constructor(e=""){super("Adds a '_context' to every object that is probably a translation",["_context"],"AddContextToTranslation");y(this,"_prefix");this._prefix=e}convert(e,n){return e["#dont-translate"]==="*"?{result:e}:{result:f.WalkJson(e,(o,s)=>{if(o==null)return o;if(typeof o=="object"){let a=e;for(let r=0;r<s.length;r++){const d=s[r];a=a[d],d.match("[0-9]+")&&a.id!==void 0&&(s[r]=a.id)}return{...o,_context:this._prefix+n+"."+s.join(".")}}else return o},o=>o==null||R.isProbablyATranslation(o))}}}const Oe="filters",Me="This layer acts as library for common filters",Ne=null,Fe={osmTags:"id~*"},Ee=[{id:"open_now",options:[{question:{en:"Opened now",nl:"Nu geopened",de:"Aktuell geöffnet",ca:"Obert ara",es:"Abierta ahora",fr:"Ouvert maintenant",hu:"Most nyitva van",da:"Åbent nu",zh_Hant:"目前開放",id:"Saat ini buka",it:"Aperto ora"},osmTags:"_isOpen=yes"}]},{id:"accepts_cash",options:[{osmTags:"payment:cash=yes",question:{en:"Accepts cash",de:"Akzeptiert Bargeld",nl:"Accepteert cash",es:"Acepta efectivo",fr:"Accepte les espèces"}}]},{id:"accepts_cards",options:[{osmTags:"payment:cards=yes",question:{en:"Accepts payment cards",de:"Akzeptiert Kartenzahlung",nl:"Accepteert betaalkaarten",es:"Acepta el pago por tarjeta",fr:"Accepte les cartes de paiement"}}]},{id:"has_image",options:[{question:{en:"With and without images",nl:"Met en zonder afbeelding",de:"Mit und ohne Bild"}},{question:{en:"Has at least one image",de:"Hat mindestens ein Bild",nl:"Heeft minstens één afbeelding"},osmTags:{or:["image~*","image:0~*","image:1~*","image:2~*","image:3~*","mapillary~*"]}},{question:{en:"Probably does not have an image",de:"Hat wahrscheinlich kein Bild",nl:"Heeft waarschijnlijk geen afbeelding"},osmTags:{and:["image=","image:0=","image:1=","image:2=","image:3=","mapillary="]}}]},{id:"tactile_paving",options:[{question:{en:"With tactile paving",de:"Mit taktilem Pflaster",fr:"Avec revêtement podotactile",nl:"Met voelbare bestrating"},osmTags:"tactile_paving=yes"}]},{id:"tactile_paving_advanced","#":"ignore-possible-duplicate",options:[{question:{en:"With or without tactile paving",de:"Mit oder ohne taktilem Pflaster",fr:"Avec ou sans revêtement podotactile",nl:"Met of zonder voelbare bestrating"}},{question:{en:"With tactile paving",de:"Mit taktilem Pflaster",fr:"Avec revêtement podotactile",nl:"Met voelbare bestrating"},osmTags:"tactile_paving=yes"},{question:{en:"Without tactile paving",de:"Ohne taktilem Pflaster",fr:"Sans revêtement podotactile",nl:"Zonder voelbare bestrating"},osmTags:"tactile_paving=no"},{osmTags:"tactile_paving=",question:{en:"No information about tactile paving",de:"Keine Informationen über taktiles Pflaster",fr:"Sans information sur le revêtement podotactile",nl:"Geen informatie over voelbare bestrating"}}]},{id:"has_organic",options:[{osmTags:{or:["organic=yes","organic=only"]},question:{en:"Has organic options",de:"Bio-Produkte im Angebot",nl:"Heeft biologische opties"}}]}],Pe={id:Oe,description:Me,mapRendering:Ne,source:Fe,filter:Ee},O=class extends w{constructor(e){super("Expands filters: replaces a shorthand by the value found in 'filters.json'. If the string is formatted 'layername.filtername, it will be looked up into that layer instead",["filter"],"ExpandFilter");y(this,"_state");this._state=e}static load_filters(){let e=new Map;for(const n of Pe.filter)e.set(n.id,n);return e}convert(e,n){if(e.filter===void 0||e.filter===null)return{result:e};if(e.filter.sameAs!==void 0)return{result:e};const t=[],o=[];for(const s of e.filter){if(typeof s!="string"){t.push(s);continue}if(s.indexOf(".")>0){if(this._state.sharedLayers.size>0){const r=s.split(".");r.length>2&&o.push(n+": invalid filter name: "+s+", expected `layername.filterid`");const d=this._state.sharedLayers.get(r[0]);d===void 0&&o.push(n+": layer '"+r[0]+"' not found");const c=r[1],h=d.filter.find(l=>typeof l!="string"&&l.id===c);t.push(h)}continue}const a=O.predefinedFilters.get(s);if(a===void 0){const r=f.sortedByLevenshteinDistance(s,Array.from(O.predefinedFilters.keys()),c=>c),d=n+".filter: while searching for predifined filter "+s+": this filter is not found. Perhaps you meant one of: "+r;o.push(d)}t.push(a)}return{result:{...e,filter:t},errors:o}}};let M=O;y(M,"predefinedFilters",O.load_filters());class E extends H{constructor(e,n,t){super("Converts a tagRenderingSpec into the full tagRendering, e.g. by substituting the tagRendering by the shared-question",[],"ExpandTagRendering");y(this,"_state");y(this,"_self");y(this,"_options");this._state=e,this._self=n,this._options=t}convert(e,n){const t=[],o=[];return{result:this.convertUntilStable(e,o,t,n),errors:t,warnings:o}}lookup(e){const n=this.directLookup(e);if(n===void 0)return;const t=[];for(const o of n)if(o.builtin!==void 0){let s=o.builtin,a;typeof s=="string"?a=this.lookup(s):a=[].concat(...s.map(r=>this.lookup(r)));for(let r of a)r=f.Clone(r),f.Merge(o.override??{},r),r.id=o.id??r.id,t.push(r)}else t.push(o);return t}directLookup(e){var c;const n=this._state;if(n.tagRenderings.has(e))return[n.tagRenderings.get(e)];if(e.indexOf(".")<0)return;const t=e.split(".");let o=n.sharedLayers.get(t[0]);if(t[0]===this._self.id&&(o=this._self),t.length!==2||o===void 0)return;const s=t[1],a=o.tagRenderings.filter(h=>h.id!==void 0);let r;if(s==="*")r=a;else if(s.startsWith("*")){const h=s.substring(1);r=a.filter(l=>{var u;return l.group===h||((u=l.labels)==null?void 0:u.indexOf(h))>=0})}else r=a.filter(h=>{var l;return h.id===s||((l=h.labels)==null?void 0:l.indexOf(s))>=0});const d=new re("layers:");for(let h=0;h<r.length;h++){let l=f.Clone(r[h]);(c=this._options)!=null&&c.applyCondition&&(l.condition===void 0?l.condition=o.source.osmTags:l.condition={and:[l.condition,o.source.osmTags]}),l=d.convertStrict(l,o.id+".tagRenderings."+l.id),r[h]=l}if(r.length!==0)return r}convertOnce(e,n,t,o){var a;const s=this._state;if(e==="questions")return[{id:"questions"}];if(typeof e=="string"){const r=this.lookup(e);return r===void 0?(o.indexOf("On(mapRendering")<0&&this._state.sharedLayers.size>0&&n.push(`${o}: A literal rendering was detected: ${e}
    Did you perhaps forgot to add a layer name as 'layername.${e}'? `+Array.from(s.sharedLayers.keys()).join(", ")),(a=this._options)!=null&&a.noHardcodedStrings&&this._state.sharedLayers.size>0&&t.push(o+"Detected an invocation to a builtin tagRendering, but this tagrendering was not found: "+e+" \n    Did you perhaps forget to add the layer as prefix, such as `icons."+e+"`? "),[{render:e,id:e.replace(/[^a-zA-Z0-9]/g,"")}]):r}if(e.builtin!==void 0){let r=e.builtin;typeof r=="string"&&(r=[r]);for(const c of Object.keys(e))c==="builtin"||c==="override"||c==="id"||c.startsWith("#")||t.push("At "+o+": an object calling a builtin can only have keys `builtin` or `override`, but a key with name `"+c+"` was found. This won't be picked up! The full object is: "+JSON.stringify(e));const d=[];for(const c of r){const h=this.lookup(c);if(h===void 0){let l=Array.from(s.tagRenderings.keys());if(c.indexOf(".")>0){const[u]=c.split(".");let v=s.sharedLayers.get(u);if(u===this._self.id&&(v=this._self),v===void 0){const p=f.sortedByLevenshteinDistance(u,Array.from(s.sharedLayers.keys()),m=>m);s.sharedLayers.size===0?n.push(o+": BOOTSTRAPPING. Rerun generate layeroverview. While reusing tagrendering: "+c+": layer "+u+" not found. Maybe you meant on of "+p.slice(0,3).join(", ")):t.push(o+": While reusing tagrendering: "+c+": layer "+u+" not found. Maybe you meant on of "+p.slice(0,3).join(", "));continue}l=f.NoNull(v.tagRenderings.map(p=>p.id)).map(p=>u+"."+p)}l=f.sortedByLevenshteinDistance(c,l,u=>u),t.push(o+": The tagRendering with identifier "+c+` was not found.
	Did you mean one of `+l.join(", ")+`?
(Hint: did you add a new label and are you trying to use this label at the same time? Run 'reset:layeroverview' first`);continue}for(let l of h)l=f.Clone(l),f.Merge(e.override??{},l),d.push(l)}return d}return[e]}convertUntilStable(e,n,t,o){const s=this.convertOnce(e,n,t,o),a=[];for(const r of s)if(typeof r=="string"||r.builtin!==void 0){const d=this.convertUntilStable(r,n,t,o+"(RECURSIVE RESOLVE)");a.push(...d)}else a.push(r);return a}}class P extends H{constructor(){super("Applies a rewrite",[],"ExpandRewrite")}static RewriteParts(i,e,n){const t=R.isProbablyATranslation(e);function o(s,a){if(s===i)return a;if(typeof s=="string"){for(;s.indexOf(i)>=0;)s=s.replace(i,a);return s}if(Array.isArray(s))return s.map(r=>o(r,a));if(typeof s=="object"){s={...s};const r=t&&R.isProbablyATranslation(s);for(const d in s){let c=a;r&&a[d]!==void 0&&(c=a[d]),s[d]=o(s[d],c)}return s}return s}return o(n,e)}convert(i,e){if(i==null)return{result:[]};if(i.rewrite===void 0)return{result:[i]};const n=i,t=n.rewrite,o=[];for(let s=0;s<t.sourceString.length;s++){const a=t.sourceString[s];for(let r=s+1;r<t.sourceString.length;r++){const d=t.sourceString[r];if(d.indexOf(a)>=0)throw`${e} Error in rewrite: sourcestring[${s}] is a substring of sourcestring[${r}]: ${a} will be substituted away before ${d} is reached.`}}for(let s=0;s<n.rewrite.into.length;s++){const a=t.into[s];if(a.length!==n.rewrite.sourceString.length)throw`${e}.into.${s} Error in rewrite: there are ${n.rewrite.sourceString.length} keys to rewrite, but entry ${s} has only ${a.length} values`}for(let s=0;s<t.into.length;s++){let a=f.Clone(n.renderings);for(let r=0;r<t.sourceString.length;r++){const d=t.sourceString[r],c=t.into[s][r];a=P.RewriteParts(d,c,a)}o.push(a)}return{result:o}}}class J extends w{constructor(){super("Converts a 'special' translation into a regular translation which uses parameters",["special"],"RewriteSpecial")}static convertIfNeeded(i,e,n){const t=i.special;if(t===void 0)return i;const o=t.type;if(o===void 0){e.push("A 'special'-block should define 'type' to indicate which visualisation should be used");return}const s=Q.specialVisualizations.find(p=>p.funcName===o);if(s===void 0){const p=f.sortedByLevenshteinDistance(o,Q.specialVisualizations,m=>m.funcName);e.push(`Special visualisation '${o}' not found. Did you perhaps mean ${p[0].funcName}, ${p[1].funcName} or ${p[2].funcName}?
	For all known special visualisations, please see https://github.com/pietervdvn/MapComplete/blob/develop/Docs/SpecialRenderings.md`);return}e.push(...Array.from(Object.keys(i)).filter(p=>p!=="special"&&p!=="before"&&p!=="after").map(p=>`At ${n}: The only keys allowed next to a 'special'-block are 'before' and 'after'. Perhaps you meant to put '${p}' into the special block?`));const a=s.args.map(p=>p.name),r=new Set(a);e.push(...Object.keys(t).filter(p=>!r.has(p)).filter(p=>p!=="type"&&p!=="before"&&p!=="after").map(p=>{const m=f.sortedByLevenshteinDistance(p,a,A=>A);return`At ${n}: Unexpected argument in special block at ${n} with name '${p}'. Did you mean ${m[0]}?
	All known arguments are ${a.join(", ")}`}));for(const p of s.args){if(p.required!==!0)continue;t[p.name]===void 0&&e.push(`At ${n}: Obligated parameter '${p.name}' in special rendering of type ${s.funcName} not found.
${p.doc}`)}const d=new Set,c=a.map(p=>t[p]).filter(p=>p!==void 0).filter(p=>R.isProbablyATranslation(p));for(const p of c)for(const m of Object.keys(p))d.add(m);const h=R.T(i.before),l=R.T(i.after);for(const p of Object.keys((h==null?void 0:h.translations)??{}))d.add(p);for(const p of Object.keys((l==null?void 0:l.translations)??{}))d.add(p);if(d.size===0){const p=a.map(m=>t[m]??"").join(",");return{"*":`{${o}(${p})}`}}const u={},v=Array.from(d);v.sort();for(const p of v){const m=[];for(const $ of a){let L=t[$]??"";if(R.isProbablyATranslation(L)&&(L=new ee(L).textFor(p)),typeof L=="string"){const oe=L.replace(/,/g,"&COMMA").replace(/\{/g,"&LBRACE").replace(/}/g,"&RBRACE").replace(/\(/g,"&LPARENS").replace(/\)/g,"&RPARENS");m.push(oe)}else typeof L=="object"?m.push(JSON.stringify(L)):m.push(L)}const A=(h==null?void 0:h.textFor(p))??"",_=(l==null?void 0:l.textFor(p))??"";u[p]=`${A}{${o}(${m.map($=>$).join(",")})}${_}`}return u}convert(i,e){const n=[];i=f.Clone(i);const t=De;for(const o of t)o.typeHint==="rendered"&&f.WalkPath(o.path,i,(s,a)=>J.convertIfNeeded(s,n,e+":"+a.join(".")));return{result:i,errors:n}}}class Be extends w{constructor(e,n){super("Expands shorthand properties on iconBadges",["iconBadges"],"ExpandIconBadges");y(this,"_state");y(this,"_layer");y(this,"_expand");this._state=e,this._layer=n,this._expand=new E(e,n)}convert(e,n){if(!e.iconBadges)return{result:e};const t=e.iconBadges,o=[],s=[],a=[];for(let r=0;r<t.length;r++){const d=t[r],{errors:c,result:h,warnings:l}=this._expand.convert(d.then,n+".iconBadges["+r+"]");if(s.push(...c),a.push(...l),h===void 0){o.push(d);continue}o.push(...h.map(u=>({if:d.if,then:u})))}return{result:{...e,iconBadges:o},errors:s,warnings:a}}}class qe extends k{constructor(i,e){super("Prepares point renderings by expanding 'icon' and 'iconBadges'",new b("icon",new fe(new E(i,e,{applyCondition:!1}))),new Be(i,e))}}class X extends k{constructor(i){super("Fully prepares and expands a layer for the LayerConfig.",new b("tagRenderings",new S(new J)),new b("tagRenderings",new D(new P).andThenF(f.Flatten)),new b("tagRenderings",e=>new D(new E(i,e))),new b("mapRendering",new D(new P).andThenF(f.Flatten)),new b("mapRendering",e=>new S(new qe(i,e))),new ne("titleIcons",["icons.defaults"]),new b("titleIcons",e=>new D(new E(i,e,{noHardcodedStrings:!0}))),new M(i))}}class U{static GetTagRenderingDependencies(i){if(i===void 0)throw"Got undefined tag rendering in getTagRenderingDependencies";const e=[],n=[].concat(...i.EnumerateTranslations().map(t=>t.AllValues()));for(const t of n){const o=ie.ExtractSpecialComponents(t).map(s=>s.special).filter(s=>{var a;return((a=s==null?void 0:s.func)==null?void 0:a.getLayerDependencies)!==void 0});for(const s of o)e.push(...s.func.getLayerDependencies(s.args))}return e}static getLayerDependencies(i){var n,t,o;const e=[];for(let s=0;i.presets!==void 0&&s<i.presets.length;s++)(t=(n=i.presets[s].preciseInput)==null?void 0:n.snapToLayers)==null||t.forEach(r=>{e.push({neededLayer:r,reason:"a preset snaps to this layer",context:"presets["+s+"]",neededBy:i.id})});for(const s of i.AllTagRenderings())for(const a of U.GetTagRenderingDependencies(s))e.push({neededLayer:a,reason:"a tagrendering needs this layer",context:s.id,neededBy:i.id});if(((o=i.calculatedTags)==null?void 0:o.length)>0){const s={type:"Feature",geometry:{type:"Point",coordinates:[0,0]},properties:{id:"node/1"}};let a,r;const d={getFeatureById:c=>{},getFeaturesWithin:(c,h)=>c==="*"?[]:(e.push({neededLayer:c,reason:"a calculated tag loads features from this layer",context:"calculatedTag["+r+"] which calculates the value for "+a,neededBy:i.id}),[]),memberships:void 0};Ce.FullPatchFeature(d,s);for(let c=0;c<i.calculatedTags.length;c++){const[h,l]=i.calculatedTags[c];r=c,a=h;try{const v=new Function("feat","return "+l+";")(s);s.properties[h]=JSON.stringify(v)}catch{}}}return e}}class He extends H{constructor(e){super("Converts the identifier of a builtin layer into the actual layer, or converts a 'builtin' syntax with override in the fully expanded form",[],"SubstituteLayer");y(this,"_state");this._state=e}convert(e,n){const t=[],o=[],s=this._state;function a(r){const c=Array.from(s.sharedLayers.keys()).map(l=>[l,f.levenshteinDistance(r,l)]);c.sort((l,u)=>l[1]-u[1]);const h=c.map(l=>l[0]);t.push(`${n}: The layer with name ${r} was not found as a builtin layer. Perhaps you meant ${h[0]}, ${h[1]} or ${h[2]}?
 For an overview of all available layers, refer to https://github.com/pietervdvn/MapComplete/blob/develop/Docs/BuiltinLayers.md`)}if(typeof e=="string"){const r=s.sharedLayers.get(e);return r===void 0?(a(e),{result:null,errors:t}):{result:[r],errors:t}}if(e.builtin!==void 0){let r=e.builtin;typeof r=="string"&&(r=[r]);const d=[];for(const c of r){const h=f.Clone(s.sharedLayers.get(c));if(h===void 0){a(c);continue}e.override.tagRenderings!==void 0&&(h.tagRenderings??[]).length>0&&t.push(`At ${n}: when overriding a layer, an override is not allowed to override into tagRenderings. Use "+tagRenderings" or "tagRenderings+" instead to prepend or append some questions.`);try{f.Merge(e.override,h),d.push(h)}catch(l){t.push(`At ${n}: could not apply an override due to: ${l}.
The override is: ${JSON.stringify(e.override)}`)}if(e.hideTagRenderingsWithLabels){const l=new Set(e.hideTagRenderingsWithLabels),u=new Set,v=[];for(const m of h.tagRenderings){const A=m.labels;if(A!==void 0){const _=A.findIndex($=>l.has($));if(_>=0){u.add(A[_]),o.push(n+": Dropping tagRendering "+m.id+" as it has a forbidden label: "+A[_]);continue}}if(l.has(m.id)){u.add(m.id),o.push(n+": Dropping tagRendering "+m.id+" as its id is a forbidden label");continue}if(l.has(m.group)){u.add(m.group),o.push(n+": Dropping tagRendering "+m.id+" as its group `"+m.group+"` is a forbidden label");continue}v.push(m)}const p=Array.from(l).filter(m=>!u.has(m));p.length>0&&t.push("This theme specifies that certain tagrenderings have to be removed based on forbidden layers. One or more of these layers did not match any tagRenderings and caused no deletions: "+p.join(", ")+`
   This means that this label can be removed or that the original tagRendering that should be deleted does not have this label anymore`),h.tagRenderings=v}}return{result:d,errors:t,information:o}}return{result:[e],errors:t}}}class Je extends w{constructor(e){super("Adds the default layers, namely: "+C.added_by_default.join(", "),["layers"],"AddDefaultLayers");y(this,"_state");this._state=e}convert(e,n){const t=[],o=[],s=this._state;e.layers=[...e.layers];const a=new Set(e.layers.map(r=>r.id));for(const r of C.added_by_default){const d=s.sharedLayers.get(r);if(d===void 0){t.push("Default layer "+r+" not found");continue}if(a.has(d.id)){o.push("Layout "+n+" already has a layer with name "+d.id+"; skipping inclusion of this builtin layer");continue}e.layers.push(d)}return{result:e,errors:t,warnings:o}}}class Ue extends w{constructor(){super("For every layer in the 'layers'-list, create a new layer which'll import notes. (Note that priviliged layers and layers which have a geojson-source set are ignored)",["layers"],"AddImportLayers")}convert(i,e){if(!(i.enableNoteImports??!0))return{warnings:["Not creating a note import layers for theme "+i.id+" as they are disabled"],result:i};const n=[];i={...i};const t=i.layers;i.layers=[...i.layers];const o=new xe;for(let s=0;s<t.length;s++){const a=t[s];if(!(C.priviliged_layers.indexOf(a.id)>=0)&&a.source.geoJson===void 0&&!(a.title===void 0||a.name===void 0)&&!(a.presets===void 0||a.presets.length==0))try{const r=o.convert(a,e+".(noteimportlayer)["+s+"]");r.result!==void 0&&i.layers.push(r.result)}catch(r){n.push("Could not generate an import-layer for "+a.id+" due to "+r)}}return{errors:n,result:i}}}class z extends w{constructor(e){super("Adds a default 'minimap'-element to the tagrenderings if none of the elements define such a minimap",["tagRenderings"],"AddMiniMap");y(this,"_state");this._state=e}static hasMinimap(e){const n=f.NoNull([e.render,...(e.mappings??[]).map(t=>t.then)]);for(let t of n){typeof t=="string"&&(t={"*":t});for(const o in t){if(!t.hasOwnProperty(o))continue;const s=t[o];if(ie.ExtractSpecialComponents(s).filter(d=>d.special!==void 0).some(d=>d.special.func.funcName==="minimap"))return!0}}return!1}convert(e,n){var s;const t=this._state;return(((s=e.tagRenderings)==null?void 0:s.some(a=>z.hasMinimap(a)))??!0)||(e={...e},e.tagRenderings=[...e.tagRenderings],e.tagRenderings.push(t.tagRenderings.get("questions")),e.tagRenderings.push(t.tagRenderings.get("minimap"))),{result:e}}}class ze extends w{constructor(){super("Adds context to translations, including the prefix 'themes:json.id'; this is to make sure terms in an 'overrides' or inline layer are linkable too",["_context"],"AddContextToTranlationsInLayout")}convert(i,e){return new re("themes:").convert(i,i.id)}}class We extends w{constructor(){super("Applies 'overrideAll' onto every 'layer'. The 'overrideAll'-field is removed afterwards",["overrideAll","layers"],"ApplyOverrideAll")}convert(i,e){const n=i.overrideAll;if(n===void 0)return{result:i,warnings:[],errors:[]};i={...i},delete i.overrideAll;const t=[];for(let o of i.layers)o=f.Clone(o),f.Merge(n,o),t.push(o);return i.layers=t,{result:i,warnings:[],errors:[]}}}class W extends w{constructor(e){super(`If a layer has a dependency on another layer, these layers are added automatically on the theme. (For example: defibrillator depends on 'walls_and_buildings' to snap onto. This layer is added automatically)
            
            Note that these layers are added _at the start_ of the layer list, meaning that they will see _every_ feature.
            Furthermore, \`passAllFeatures\` will be set, so that they won't steal away features from further layers.
            Some layers (e.g. \`all_buildings_and_walls' or 'streets_with_a_name') are invisible, so by default, 'force_load' is set too.
            `,["layers"],"AddDependencyLayersToTheme");y(this,"_state");this._state=e}static CalculateDependencies(e,n,t){const o=[],s=new Set(e.map(r=>r.id));let a=[];do{const r=[];for(const d of e)try{const c=U.getLayerDependencies(new ye(d,t+"(dependencies)"));r.push(...c)}catch(c){throw console.error(c),"Detecting layer dependencies for "+d.id+" failed due to "+c}for(const d of r)s.has(d.neededLayer)&&(e.find(c=>c.id===d.neededLayer).forceLoad=!0);a=r.filter(d=>!s.has(d.neededLayer));for(const d of a){if(s.has(d.neededLayer))continue;const c=f.Clone(n.get(d.neededLayer)),h="This layer is needed by "+d.neededBy+" because "+d.reason+" (at "+d.context+")";if(c===void 0)throw["Loading a dependency failed: layer "+d.neededLayer+" is not found, neither as layer of "+t+" nor as builtin layer.",h,"Loaded layers are: "+e.map(u=>u.id).join(",")].join(`
	`);c.forceLoad=!0,c.passAllFeatures=!0,c.description=h,o.unshift({config:c,reason:h}),s.add(c.id),a=a.filter(l=>l.neededLayer!==d.neededLayer)}}while(a.length>0);return o}convert(e,n){const t=this._state,o=t.sharedLayers,s=t.tagRenderings,a=[],r=e.layers;s.forEach((c,h)=>{c.id=h});const d=W.CalculateDependencies(r,o,e.id);for(const c of d);if(d.length>0)for(const c of d)a.push(n+": added "+c.config.id+" to the theme. "+c.reason);return r.unshift(...d.map(c=>c.config)),{result:{...e,layers:r},information:a}}}class Ve extends w{constructor(e){super("Adds every public layer to the personal theme",["layers"],"PreparePersonalTheme");y(this,"_state");this._state=e}convert(e,n){return e.id!=="personal"?{result:e}:(e.layers=Array.from(this._state.sharedLayers.keys()).filter(t=>C.priviliged_layers.indexOf(t)<0).filter(t=>this._state.publicLayers.has(t)),{result:e,information:["The personal theme has "+e.layers.length+" public layers"]})}}class Ge extends w{constructor(){super("Generates a warning if a theme uses an unsubstituted layer",["layers"],"WarnForUnsubstitutedLayersInTheme")}convert(i,e){if(i.hideFromOverview===!0)return{result:i};const n=[];for(const t of i.layers){if(typeof t=="string"||t.builtin!==void 0||t.source.geojson!==void 0)continue;const o="The theme "+i.id+" has an inline layer: "+t.id+". This is discouraged.";n.push(o)}return{result:i,warnings:n}}}class Qe extends k{constructor(i,e){super("Fully prepares and expands a theme",new ze,new Ve(i),new Ge,new b("layers",new D(new He(i))),new ne("socialImage","assets/SocialImage.png",!0),new b("layers",new S(new X(i))),new We,new b("layers",new S(new X(i))),e!=null&&e.skipDefaultLayers?new me("AddDefaultLayers is disabled due to the set flag"):new Je(i),new W(i),new Ue,new b("layers",new S(new z(i))))}}class j extends w{constructor(...e){super("Checks that the given object is fully translated in the specified languages",[],"ValidateLanguageCompleteness");y(this,"_languages");this._languages=e??["en"]}convert(e,n){const t=[],o=ee.ExtractAllTranslationsFrom(e);for(const s of this._languages)o.filter(a=>a.tr.translations[s]===void 0&&a.tr.translations["*"]===void 0).forEach(a=>{t.push(n+"A theme should be translation-complete for "+s+", but it lacks a translation for "+a.context+`.
	The known translation is `+a.tr.textFor("en"))});return{result:e,errors:t}}}class Ke extends w{constructor(e,n=void 0,t){super("Checks if an image exists",[],"DoesImageExist");y(this,"_knownImagePaths");y(this,"_ignore");y(this,"doesPathExist");this._ignore=t,this._knownImagePaths=e,this.doesPathExist=n}convert(e,n){var a;if((a=this._ignore)!=null&&a.has(e))return{result:e};const t=[],o=[],s=[];return e.indexOf("{")>=0?(s.push("Ignoring image with { in the path: "+e),{result:e}):e==="assets/SocialImage.png"?{result:e}:e.match(/[a-z]*/)&&B.All[e+".svg"]!==void 0?{result:e}:(this._knownImagePaths.has(e)||(this.doesPathExist===void 0?t.push(`Image with path ${e} not found or not attributed; it is used in ${n}`):this.doesPathExist(e)?t.push(`Image with path ${e} is not attributed (but it exists); execute 'npm run query:licenses' to add the license information and/or run 'npm run generate:licenses' to compile all the license info`):t.push(`Image with path ${e} does not exist; it is used in ${n}.
     Check for typo's and missing directories in the path.`)),{result:e,errors:t,warnings:o,information:s})}}class Ze extends w{constructor(e,n,t,o){super("Doesn't change anything, but emits warnings and errors",[],"ValidateTheme");y(this,"_path");y(this,"_isBuiltin");y(this,"_validateImage");y(this,"_extractImages");this._validateImage=e,this._path=n,this._isBuiltin=t,o&&(this._extractImages=new we(this._isBuiltin,o))}convert(e,n){const t=[],o=[],s=[],a=new se(e,this._isBuiltin);if(this._isBuiltin&&(e.units!==void 0&&t.push("The theme "+e.id+" has units defined - these should be defined on the layer instead. (Hint: use overrideAll: { '+units': ... }) "),e.roamingRenderings!==void 0&&t.push("Theme "+e.id+" contains an old 'roamingRenderings'. Use an 'overrideAll' instead")),this._isBuiltin&&this._extractImages!==void 0){const r=this._extractImages.convertStrict(e,"validation"),d=r.filter(c=>c.path.indexOf("http")==0);for(const c of d)t.push("Found a remote image: "+c+" in theme "+e.id+", please download it.");for(const c of r)this._validateImage.convertJoin(c.path,n===void 0?"":` in the theme ${n} at ${c.context}`,t,o,s)}try{if(this._isBuiltin){a.id!==a.id.toLowerCase()&&t.push("Theme ids should be in lowercase, but it is "+a.id);const d=this._path.substring(this._path.lastIndexOf("/")+1,this._path.length-5);a.id!==d&&t.push("Theme ids should be the same as the name.json, but we got id: "+a.id+" and filename "+d+" ("+this._path+")"),this._validateImage.convertJoin(a.icon,n+".icon",t,o,s)}const r=f.Dupiclates(e.layers.map(d=>d.id));if(r.length>0&&t.push(`The theme ${e.id} defines multiple layers with id ${r.join(", ")}`),e.mustHaveLanguage!==void 0){const d=new j(...e.mustHaveLanguage).convert(a,a.id);t.push(...d.errors)}if(!e.hideFromOverview&&a.id!=="personal"&&this._isBuiltin){const d=a.title.SupportedLanguages()[0];d!=="en"&&o.push(`TargetLanguage is not 'en' for public theme ${a.id}, it is ${d}. Move 'en' up in the title of the theme and set it as the first key`);const c=new j("en").convert(a,a.id);t.push(...c.errors)}}catch(r){t.push(r)}return{result:e,errors:t,warnings:o,information:s}}}class Ye extends k{constructor(i,e,n,t){super("Validates a theme and the contained layers",new Ze(i,e,n,t),new b("layers",new S(new st(void 0,n,i))))}}class Xe extends w{constructor(){super("Checks that an 'overrideAll' does not override a single override",[],"OverrideShadowingCheck")}convert(i,e){const n=i.overrideAll;if(n===void 0)return{result:i};const t=[],o=i.layers.filter(s=>s.override!==void 0);for(const s of o)for(const a in n)if(!(a.endsWith("+")||a.startsWith("+"))&&(s.override[a]!==void 0||s.override["="+a]!==void 0)){const r="The override of layer "+JSON.stringify(s.builtin)+" has a shadowed property: "+a+" is overriden by overrideAll of the theme";t.push(r)}return{result:i,errors:t}}}class je extends w{constructor(){super("Miscelleanous checks on the theme",[],"MiscThemesChecks")}convert(i,e){const n=[],t=[];return i.id!=="personal"&&(i.layers===void 0||i.layers.length===0)&&t.push("The theme "+i.id+" has no 'layers' defined ("+e+")"),i.socialImage===""&&n.push("Social image for theme "+i.id+" is the emtpy string"),{result:i,warnings:n,errors:t}}}class et extends k{constructor(){super("Various consistency checks on the raw JSON",new je,new Xe)}}class V extends w{constructor(e){super("Checks that the mappings don't shadow each other",[],"DetectShadowedMappings");y(this,"_calculatedTagNames");this._calculatedTagNames=V.extractCalculatedTagNames(e)}static extractCalculatedTagNames(e){var n;return((n=e==null?void 0:e.calculatedTags)==null?void 0:n.map(t=>t.indexOf(":=")>=0?t.split(":=")[0]:t.split("=")[0]))??[]}convert(e,n){const t=[],o=[];if(e.mappings===void 0||e.mappings.length===0)return{result:e};const s={};for(const r of this._calculatedTagNames)s[r]="some_calculated_tag_value_for_"+r;const a=e.mappings.map((r,d)=>{const c=`${n}.mappings[${d}]`,h=F.Tag(r.if,c),l=r.hideInAnswer;if(l!==void 0&&l!==!1&&l!==!0){let u=F.Tag(l);return new ae([u,h])}return h});for(let r=0;r<e.mappings.length;r++){if(!a[r].isUsableAsAnswer())continue;const d=a[r].asChange(s),c={};d.forEach(({k:h,v:l})=>{c[h]=l});for(let h=0;h<r;h++){const l=a[h].matchesProperties(c);l&&e.mappings[h].hideInAnswer===!0&&e.mappings[r].hideInAnswer!==!0?o.push(`At ${n}: Mapping ${r} is shadowed by mapping ${h}. However, mapping ${h} has 'hideInAnswer' set, which will result in a different rendering in question-mode.`):l&&t.push(`At ${n}: Mapping ${r} is shadowed by mapping ${h} and will thus never be shown:
    The mapping ${a[r].asHumanString(!1,!1,{})} is fully matched by a previous mapping (namely ${h}), which matches:
    ${a[h].asHumanString(!1,!1,{})}.

    To fix this problem, you can try to:
    - Move the shadowed mapping up
    - Do you want to use a different text in 'question mode'? Add 'hideInAnswer=true' to the first mapping
    - Use "addExtraTags": ["key=value", ...] in order to avoid a different rendering
         (e.g. [{"if": "fee=no",                     "then": "Free to use", "hideInAnswer":true},
                {"if": {"and":["fee=no","charge="]}, "then": "Free to use"}]
          can be replaced by
               [{"if":"fee=no", "then": "Free to use", "addExtraTags": ["charge="]}]
`)}}return{errors:t,warnings:o,result:e}}}class tt extends w{constructor(e){super("Checks that 'then'clauses in mappings don't have images, but use 'icon' instead",[],"DetectMappingsWithImages");y(this,"_doesImageExist");this._doesImageExist=e}convert(e,n){var r,d;const t=[],o=[],s=[];if(e.mappings===void 0||e.mappings.length===0)return{result:e};const a="ignore-image-in-then";for(let c=0;c<e.mappings.length;c++){const h=e.mappings[c],l=((r=h["#"])==null?void 0:r.indexOf(a))>=0,u=f.Dedup(((d=R.T(h.then))==null?void 0:d.ExtractImages())??[]),v=`${n}.mappings[${c}]`;if(u.length>0)if(!l)t.push(`${v}: A mapping has an image in the 'then'-clause. Remove the image there and use \`"icon": <your-image>\` instead. The images found are ${u.join(", ")}. (This check can be turned of by adding "#": "${a}" in the mapping, but this is discouraged`);else{s.push(`${v}: Ignored image ${u.join(", ")} in 'then'-clause of a mapping as this check has been disabled`);for(const p of u)this._doesImageExist.convertJoin(p,v,t,o,s)}else l&&o.push(`${v}: unused '${a}' - please remove this`)}return{errors:t,warnings:o,information:s,result:e}}}class nt extends w{constructor(e){super("Miscellaneous checks on the tagrendering",["special"],"MiscTagRenderingChecks");y(this,"_options");this._options=e}convert(e,n){var s;const t=[],o=[];if(e.special!==void 0&&o.push("At "+n+': detected `special` on the top level. Did you mean `{"render":{ "special": ... }}`'),e.question&&!((s=this._options)!=null&&s.noQuestionHintCheck)){const a=R.T(new ce(e.question),n+".question");for(const r of a.SupportedLanguages()){const d=document.createElement("p");d.innerHTML=a.textFor(r);const c=Array.from(d.getElementsByTagName("div")),h=Array.from(d.getElementsByTagName("span")),l=Array.from(d.getElementsByTagName("br")),u=Array.from(d.getElementsByClassName("subtle"));c.length+h.length+l.length+u.length>0&&t.push(`At ${n}: the question for ${r} contains a div, a span, a br or an element with class 'subtle'. Please, use a \`questionHint\` instead.
    The question is: ${a.textFor(r)}`)}}return{result:e,errors:o,warnings:t}}}class it extends k{constructor(i,e,n){super("Various validation on tagRenderingConfigs",new V(i),new tt(e),new nt(n))}}class st extends w{constructor(e,n,t){super("Doesn't change anything, but emits warnings and errors",[],"ValidateLayer");y(this,"_path");y(this,"_isBuiltin");y(this,"_doesImageExist");this._path=e,this._isBuiltin=n,this._doesImageExist=t}convert(e,n){var a,r,d,c,h;const t=[],o=[],s=[];if(n="While validating a layer: "+n,typeof e=="string")return t.push(n+": This layer hasn't been expanded: "+e),{result:null,errors:t};if(e.tagRenderings!==void 0&&e.tagRenderings.length>0&&(e.title===void 0&&t.push(n+": this layer does not have a title defined but it does have tagRenderings. Not having a title will disable the popups, resulting in an unclickable element. Please add a title. If not having a popup is intended and the tagrenderings need to be kept (e.g. in a library layer), set `title: null` to disable this error."),e.title===null&&s.push(n+": title is `null`. This results in an element that cannot be clicked - even though tagRenderings is set.")),e.builtin!==void 0)return t.push(n+": This layer hasn't been expanded: "+e),{result:null,errors:t};e.minzoom>C.userJourney.minZoomLevelToAddNewPoints&&(((a=e.presets)==null?void 0:a.length)>0?t:o).push(`At ${n}: minzoom is ${e.minzoom}, this should be at most ${C.userJourney.minZoomLevelToAddNewPoints} as a preset is set. Why? Selecting the pin for a new item will zoom in to level before adding the point. Having a greater minzoom will hide the points, resulting in possible duplicates`);{const l=f.Dedup(f.Dupiclates(f.NoNull((e.tagRenderings??[]).map(u=>u.id)))).filter(u=>u!=="questions");l.length>0&&t.push("At "+n+": some tagrenderings have a duplicate id: "+l.join(", "))}e.deletion!==void 0&&e.deletion instanceof ve&&e.deletion.softDeletionTags===void 0&&o.push("No soft-deletion tags in deletion block for layer "+e.id);try{if(this._isBuiltin){e.overpassTags!==void 0&&t.push("Layer "+e.id+`still uses the old 'overpassTags'-format. Please use "source": {"osmTags": <tags>}' instead of "overpassTags": <tags> (note: this isn't your fault, the custom theme generator still spits out the old format)`);const l=["icon","wayHandling","roamingRenderings","roamingRendering","label","width","color","colour","iconOverlays"];for(const u of l)e[u]!==void 0&&t.push(n+": layer "+e.id+" still has a forbidden key "+u);e.hideUnderlayingFeaturesMinPercentage!==void 0&&t.push(n+": layer "+e.id+" contains an old 'hideUnderlayingFeaturesMinPercentage'"),e.isShown!==void 0&&(e.isShown.render!==void 0||e.isShown.mappings!==void 0)&&o.push(n+" has a tagRendering as `isShown`")}if(this._isBuiltin){const l=`assets/layers/${e.id}/${e.id}.json`;this._path!=null&&this._path.indexOf(l)<0&&t.push("Layer is in an incorrect place. The path is "+this._path+", but expected "+l)}if(this._isBuiltin){if((r=e.tagRenderings)!=null&&r.some(u=>u.id==="")){const u=[];for(let v=0;v<e.tagRenderings.length;v++)e.tagRenderings[v].id===""&&u.push(v);t.push(`Some tagrendering-ids are empty or have an emtpy string; this is not allowed (at ${n}.tagRenderings.[${u.join(",")}])`)}const l=f.Dupiclates((d=e.tagRenderings??[])==null?void 0:d.map(u=>u.id).filter(u=>u!=="questions"));l.length>0&&!f.runningFromConsole&&t.push(`Some tagRenderings have a duplicate id: ${l} (at ${n}.tagRenderings)`),e.description===void 0&&(C.priviliged_layers.indexOf(e.id)>=0?t.push(n+": A priviliged layer must have a description"):o.push(n+": A builtin layer should have a description"))}if(e.tagRenderings!==void 0){const l=new b("tagRenderings",new S(new it(e,this._doesImageExist,{noQuestionHintCheck:((c=e["#"])==null?void 0:c.indexOf("no-question-hint-check"))>=0}))).convert(e,n);o.push(...l.warnings??[]),t.push(...l.errors??[]),s.push(...l.information??[])}{const l=(h=e.mapRendering)==null?void 0:h.filter(u=>u.icon!==void 0&&u.icon.condition!==void 0);(l==null?void 0:l.length)>0&&t.push("At "+n+`:
    One or more icons in the mapRenderings have a condition set. Don't do this, as this will result in an invisible but clickable element. Use extra filters in the source instead. The offending mapRenderings are:
`+JSON.stringify(l,null,"  "))}if(e.presets!==void 0){const l=F.Tag(e.source.osmTags);for(let u=0;u<e.presets.length;u++){const v=e.presets[u],p=new ae(v.tags.map(_=>F.Tag(_))).asChange({id:"node/-1"}),m={};for(const _ of p)m[_.k]=_.v;l.matchesProperties(m)||t.push(n+".presets["+u+`]: This preset does not match the required tags of this layer. This implies that a newly added point will not show up.
    A newly created point will have properties: `+JSON.stringify(m)+`
    The required tags are: `+l.asHumanString(!1,!1,{}))}}}catch(l){t.push(l)}return{result:e,errors:t,warnings:o,information:s}}}const T=class{static async GetLayout(){const i=q.GetQueryParameter("userlayout","false",`If not 'false', a custom (non-official) theme is loaded. This custom layout can be done in multiple ways: 

- The hash of the URL contains a base64-encoded .json-file containing the theme definition
- The hash of the URL contains a lz-compressed .json-file, as generated by the custom theme generator
- The parameter itself is an URL, in which case that URL will be downloaded. It should point to a .json of a theme`),e=decodeURIComponent(i.data);if(e.startsWith("http"))return await T.LoadRemoteTheme(e);if(e!=="false")return T.LoadLayoutFromHash(i);let n;const t=window.location.pathname.split("/").slice(-1)[0];return t!=="theme.html"&&t!==""&&(n=t,t.endsWith(".html")&&(n=t.substr(0,t.length-5)),console.log("Using layout",n)),n=q.GetQueryParameter("layout",n,"The layout to load into MapComplete").data,Se.allKnownLayouts.get(n==null?void 0:n.toLowerCase())}static LoadLayoutFromHash(i){var t,o;let e=location.hash.substr(1),n;try{const s=G.Get("user-layout-"+((t=i.data)==null?void 0:t.replace(" ","_")));((o=s.data)==null?void 0:o.length)<10&&s.setData(void 0);const a=G.Get("last-loaded-user-layout");e.length<10?e=s.data??a.data:(console.log("Saving hash to local storage"),a.setData(e),s.setData(e));try{n=JSON.parse(atob(e))}catch{try{n=JSON.parse(f.UnMinify(he.decompressFromBase64(e)))}catch(c){return console.error(c),T.ShowErrorOnCustomTheme("Could not decode the hash",new x("Not a valid (LZ-compressed) JSON")),null}}const r=T.prepCustomTheme(n);return i.setData(r.id),r}catch(s){return console.error(s),(e===void 0||e.length<10)&&T.ShowErrorOnCustomTheme("Could not load a theme from the hash",new x("Hash does not contain data"),n),this.ShowErrorOnCustomTheme("Could not parse the hash",new x(s),n),null}}static ShowErrorOnCustomTheme(i="Error: could not parse the custom layout:",e,n){new te([i,e.SetClass("alert"),new Z(B.back_svg(),"Go back to the theme overview",{url:window.location.protocol+"//"+window.location.host+"/index.html",newTab:!1}),n!==void 0?new Z(B.download_svg(),"Download the JSON file").onClick(()=>{f.offerContentsAsDownloadableFile(JSON.stringify(n,null,"  "),"theme_definition.json")}):void 0]).SetClass("flex flex-col clickable").AttachTo("centermessage")}static prepCustomTheme(i,e,n){if(i.layers===void 0&&i.tagRenderings!==void 0){const a=i.mapRendering.map(d=>d.icon).find(d=>d!==void 0),r=new Te(a).render.txt;i={id:i.id,description:i.description,descriptionTail:{en:"<div class='alert'>Layer only mode.</div> The loaded custom theme actually isn't a custom theme, but only contains a layer."},icon:r,title:i.name,layers:[i]}}const t=new Map;for(const a in Y.layers){const r=Y.layers[a];t.set(r.id,r)}const o={tagRenderings:Ae.SharedTagRenderingJson,sharedLayers:t,publicLayers:new Set};i=new Ie().convertStrict(i,"While loading a dynamic theme");const s=i;i=new _e(T._knownImages).convertStrict(i,"While fixing the images"),i.enableNoteImports=i.enableNoteImports??!1,i=new Qe(o).convertStrict(i,"While preparing a dynamic theme"),console.log("The layoutconfig is ",i),i.id=n??i.id;{let{errors:a}=new et().convert(i,"validation");if(a.length>0)throw"Detected errors: "+a.join(`
`)}{let{errors:a}=new Ye(new Ke(new Set,r=>!0),"",!1).convert(i,"validation");if(a.length>0)throw"Detected errors: "+a.join(`
`)}return new se(i,!1,{definitionRaw:JSON.stringify(s,null,"  "),definedAtUrl:e})}static async LoadRemoteTheme(i){console.log("Downloading map theme from ",i),new x(`Downloading the theme from the <a href="${i}">link</a>...`).AttachTo("centermessage");try{let e=await f.downloadJson(i);try{let n=e.id;const t=new URL(i);return t.hostname==="localhost"||t.hostname==="127.0.0.1"||(n=i),console.log("Loaded remote link:",i),T.prepCustomTheme(e,i,n)}catch(n){return console.error(n),T.ShowErrorOnCustomTheme(`<a href="${i}">${i}</a> is invalid:`,new x(n),e),null}}catch(e){return console.error(e),T.ShowErrorOnCustomTheme(`<a href="${i}">${i}</a> is invalid - probably not found or invalid JSON:`,new x(e)),null}}};let N=T;y(N,"_knownImages",new Set(Array.from(be).map(i=>i.path)));Re.initialize();pe.Implement();f.DisableLongPresses();class at{static Init(i){if(i===null)return;if(i===void 0){new Le().setup();return}const e=new K;I.state=new I(i),K.state=e,window.mapcomplete_state=I.state,q.GetQueryParameter("mode","map","The mode the application starts in, e.g. 'map', 'dashboard' or 'statistics'").data==="dashboard"?new ue(I.state,e).setup():new ge(I.state,e).setup()}}document.getElementById("decoration-desktop").remove();new te(["Initializing... <br/>",new x("<a>If this message persist, something went wrong - click here to try again</a>").SetClass("link-underline small").onClick(()=>{localStorage.clear(),window.location.reload()})]).AttachTo("centermessage");N.GetLayout().then(g=>{console.log("Got ",g),at.Init(g)}).catch(g=>{console.error("Error while initializing: ",g,g.stack)});
